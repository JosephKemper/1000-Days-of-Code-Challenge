<h1>
    Day 200
</h1>
<h3>
    Thursday, 30 March, 2023
</h3>
<p>
    Today, I got a decent amount of progress on the last part of my programming final, and met with my group to demo what we had done. I was the only one who built my programs to be scalable beyond the basic requirements. 
</p>
<h1>
    Day 201
</h1>
<h3>
    Friday, 31 March, 2023
</h3>
<p>
    I finished my final! I successfully built 4 separate programs that demonstrated the principles of Abstraction, Encapsulation, Inheritance, and Polymorphism.
</p>
<h1>
    Day 202
</h1>
<h3>
    Saturday, 1 April, 2023
</h3>
<p>
    Today, I went back to some of the assignments I previously struggled with and found that I still have more to learn about encapsulation. 
</p>
<h3>
    Sunday, 2 April, 2023
</h3>
<p>
    Scheduled day off of coding. 
</p>
<h1>
    Day 203
</h1>
<h3>
    Monday, 3 April, 2023
</h3>
<p>
    Today I started studying the book Beginning Câ™¯ object-oriented programming by Dan Clark. While I am between semesters I am going to dive deeper into a few areas of Object Oriented Programming that I want a more solid foundation in before I get into Programming with Data Structures next semester. 
</p>
<h1>
    Day 204
</h1>
<h3>
    Tuesday, 4 April, 2023
</h3>
<p>
    For the class I just finished on programming with classes, they gave us a whole folder to run our C# programs out of. Between today, and yesterday, I have discovered why it is they chose that shortcut option. It is a lot of work to set up VS code to run C#. 
</p>
<h1>
    Day 205
</h1>
<h3>
    Wednesday, 5 April, 2023
</h3>
<p>
    Today, was a light day of coding. I studied a bit in my book and learned a bit more about algorithms. 
</p>
<h1>
    Day 206
</h1>
<h3>
    Thursday, 6 April, 2023
</h3>
<p>
    Today, I spent some more time in my OOP book and started learning how to use Visual Studio, instead of just VS Code. 
</p>
<h1>
    Day 207
</h1>
<h3>
    Friday, 7 April, 2023
</h3>
<p>
    Today, I dug deeper into Visual Studio. I am amazed at just how much more power it has than Visual Studio Code. I also read in my OOP book more. 
</p>
<h1>
    Day 208
</h1>
<h3>
    Saturday, 8 April, 2023
</h3>
<p>
    Today, I read more in my Object Oriented Programming book and explored more in Visual Studio. Most of my day was spent getting my next book ready to publish. It should be on Amazon in 72 hours.
</p>
<h3>
    Sunday, 9 April, 2023
</h3>
<p>
    Scheduled day off of coding
</p>
<h1>
    Day 209
</h1>
<h3>
    Monday, 10 April, 2023
</h3>
<p>
    Today, I read more in my OOP book, reviewed Python variables, strings, functions, loops, and classes, and then started going through the learning material for my next class.
</p>
<h1>
    Day 210
</h1>
<h3>
    Tuesday, 11 April, 2023
</h3>
<p>
    Today, I learned that the object portion of object oriented programming is specifically referring to a specific instance of a class. I also learned about big O notation and about thinking in terms of software efficiency. 
</p>
<h1>
    Day 211
</h1>
<h3>
    Wednesday, 12 April, 2023
</h3>
<p>
    Today, I got a quick overview of proper methods to review code, chaining, hashing, hashing functions, open addressing, sets, and sparse lists.I also learned about interfaces, abstract classes, sealed classes, and partial classes from my OOP book. 
</p>
<h1>
    Day 212
</h1>
<h3>
    Thursday, 13 April, 2023
</h3>
<p>
    Today, I got introduced to maps, linked lists, recursion, and trees. I also read more in my OOP book. 
</p>
<h1>
    Day 213
</h1>
<h3>
    Friday, 14 April, 2023
</h3>
<p>
    Today, I learned about aggregation and composition relationships in Object-Oriented Programming. A car has an aggregation relationship with its engine. The car and the engine are separate objects, and can both exist and function (in some manner) without the other, but they also join together to do more than they would by themselves. On the other hand, an order and an order item are both separate objects, but an order item cannot exist without the order, this is an example of a composition relationship. 
</p>
<h1>
    Day 214
</h1>
<h3>
    Saturday, 15 April, 2023
</h3>
<p>
    Today, I learned about and practiced with list comprehensions, methods to better plan out and refactor your code.
</p>
<h3>
    Sunday, 16 April, 2023
</h3>
<p>
    Scheduled day off from coding. 
</p>
<h1>
    Day 215
</h1>
<h3>
    Monday, 17 April, 2023
</h3>
<p>
    Today, I used list slicing to solve a problem for my data structures class. 
</p>
<h1>
    Day 216
</h1>
<h3>
    Tuesday, 18 April, 2023
</h3>
<p>
    Today, I studied about big O notation and about analyzing and practicing with algorithms. 
</p>
<h1>
    Day 217
</h1>
<h3>
    Wednesday, 19 April, 2023
</h3>
<p>
    Today, I started to analyze code for how it would translate in Big O notation. 
</p>
<h1>
    Day 218
</h1>
<h3>
    Thursday, 20 April, 2023
</h3>
<p>
    Today, I studied more about big O notation. I am not happy with my level of understanding about it, so I want to delve much deeper. 
</p>
<h1>
    Day 219
</h1>
<h3>
    Friday, 21 April, 2023
</h3>
<p>
    Today, I studied a bit more into Big O notation. It is slowly starting to make more sense. 
</p>
<h1>
    Day 220
</h1>
<h3>
    Saturday, 22 April, 2023
</h3>
<p>
    Today, I built two programs, one used a loop and then list comprehension to add divisors of a given number to a list. The other program dynamically pulled numbers from one of two lists to append them to a combined list, based on values in a third list. 
</p>
<h3>
    Sunday, 23 April, 2023
</h3>
<p>
    Scheduled day off from coding
</p>
<h1>
    Day 221
</h1>
<h3>
    Monday, 24 April, 2023
</h3>
<p>
    Today, I finished the chapter in my book on Big O notation and started to work on evaluating the assigned code for its big O notation. Last week, I was a little uneasy about my understanding of big O notation, now, I am happily feeling a lot more confident both in my understanding of big O and my ability to analyze code in general.
</p>
<h1>
    Day 222
</h1>
<h3>
    Wednesday, 25 April, 2023
</h3>
<p>
    Today, I finished studying big O notation. I am happy I dug in as much as I did to understand it. Thanks to the time I spent studying big O notation, not only do I have a better understanding of how to evaluate algorithms, I also have a better grasp of understanding code in general. Tomorrow, I will start learning about understanding code using reviews and stacks.
</p>
<h1>
    Day 223
</h1>
<h3>
    Wednesday, 26 April, 2023
</h3>
<p>
    Today, I practiced with analyzing code without running it. In this case, the code in question used the stack in different ways.
</p>
<h1>
    Day 224
</h1>
<h3>
    Thursday, 27 April, 2023
</h3>
<p>
    When I was first presented with the idea of manually reviewing code and mapping it out did not make sense at all. However, I am learning something new, and the people teaching me know a lot more than I currently do, so I put my full effort into the process. Now, I am glad I did, because I feel that reviewing code to the level I did fore this assignment made me a better programmer. 
</p>
<h1>
    Day 225
</h1>
<h3>
    Friday, 28 April, 2023
</h3>
<p>
    Today, I learned about testing code. I have had previous lessons in it, but there is still a lot to learn.
</p>
<h1>
    Day 226
</h1>
<h3>
    Saturday, 29 April, 2023
</h3>
<p>
    Today, I started analyzing code I was provided to find the bugs in it. In this case everything runs, it just does not provide the right results
</p>
<h3>
    Sunday, 30 April, 2023
</h3>
<p>
    Scheduled day off from coding.
</p>
<h1>
    Day 227
</h1>
<h3>
    Monday, 1 May, 2023
</h3>
<p>
    Today, I spent more time analyzing code for defects with the intention of fixing it. 
</p>
<h1>
    Day 228
</h1>
<h3>
    Tuesday, 2 May, 2023
</h3>
<p>
    Got two of the three defects fixed for the first program we were assigned to me. I found that instead of adding the names to the end, it was adding the names to the beginning of the queue.
</p>
<h1>
    Day 229
</h1>
<h3>
    Wednesday, 3 May, 2023
</h3>
<p>
    Today, I finished working on the last of my assignment working with queues. To accomplish this, I analyzed two programs provided to me, to figure out what they do. I used previously written test code in one of the programs and a description of what the program should do, to debug the code. And for the other program, I used a description of what the program should do, to write test code and then find and fix bugs in the code. 
</p>
<h1>
    Day 230
</h1>
<h3>
    Thursday, 4 May, 2023
</h3>
<p>
    Today, I studied about sets, and sparse lists. Tomorrow, I start a deep dive into programming with sets. 
</p>
<h1>
    Day 231
</h1>
<h3>
    Friday, 5 May, 2023
</h3>
<p>
    Today, analyzed the code I was given, the requirements I need to meet and started working on a plan for how to build the code I will be writing. I am going to be writing code to find matches in letters that might not be in the same order. 
</p>
<h1>
    Day 232
</h1>
<h3>
    Saturday, 6 May, 2023
</h3>
<p>
    Today, I wrote functions to find the intersection of two sets and join two sets without using any of the built in Python operators.
</p>
<h3>
    Sunday, 7 May, 2023
</h3>
<p>
    Scheduled day off from coding
</p>
<h1>
    Day 233
</h1>
<h3>
    Monday, 8 May, 2023
</h3>
<p>
    Today, I started working on writing code to compare check if the words given in a set, have any other words that contain all the same letters. For example, if and fi would be two words that contain the same letters and so they should be flagged by the program. 
</p>
<h1>
    Day 234
</h1>
<h3>
    Tuesday, 9 May, 2023
</h3>
<p>
    Today, I met with my group and felt underwhelmed. Instead of reasoning together, and truly working as a group, we basically did a individual programming assignment and quickly talked about it afterwards and even then only barely. I would have loved to have gained the insights of my group members, because then I would have learned how they think about how to solve problems and grown from it. I still learned something, so I can be grateful for that. I guess I would have just enjoyed more discussion. I guess I'll try again next week. 
</p>
<h1>
    Day 235
</h1>
<h3>
    Wednesday, 10 May, 2023
</h3>
<p>
    Today, I built a program in O(n) time that will check if there are any duplicate letters in a set of letters of n length. I started writing a program with goal of having it also run in O(n) time to find how many pairs of numbers can add up to 10. 
</p>
<h1>
    Day 236
</h1>
<h3>
    Thursday, 11 May, 2023
</h3>
<p>
    Today, I started working on a program to sort through a list of numbers trying to find pairs of numbers that can add up to 10. The list can be any size, and the numbers are all whole numbers, and can be positive or negative. The goal of the assignment I am working on is to build the program to run in O(n) time. 
</p>
<p>
    Building the program to run in O(n*n) time is easy, just create two for loops (one for each number you want to select) and it is done. Given our topic for the lesson, I know the solution will involve sets, but I am really not sure of how to approach this. So, the assignment in question suggests that I should spend no more than 5 minutes on this part before looking at their hint, so time to read a bit more. 
</p>
<p>
    Oh! That makes a lot of sense. Looking up a specific value in a set has an O(1) time. So, if you subtract each number from 10, that then gives you the number you need to add to it, in order to get 10. From there, you look for that number in the set, and you get a program performance of O(n), only having to loop through the program once to complete it.
</p>
<p>
    When writing my program, I forgot how to find a number in a set. A quick internet search, let me find that all I need to do is an if in statement. However, I did discover a problem with my code, as I am supposed to exclude duplicates from the numbers I found and my program does not.
</p>
<p>
    I initially tried to use a continue statement nested under an if statement, but that did not do what I wanted. From there, after struggling with the idea for a bit, I took my whole loop and asked my friendly ai search engine how I would alter the code to avoid printing out duplicate sets. At that point, I was finally able to figure out how to assemble the combined if statement I was wanting to do from the beginning. ... but for some reason it stopped the whole program from working altogether. 
</p>
<p>
    It took a bit, and finally asking my friendly AI search engine, but I figured out what I did. I had two separate sets I am using for my code, one to store the numbers in for analysis (numberSet), and one to use for checking if the number has already been printed (printedNumbers) and when I was trying to check if the number I was trying to find (numberToFind) was both in the numberSet and not in the printedNumbers, I instead asked if it was both in numberSet and not in numberSet. I feel blind that I missed that, in my multiple reviews of the code, but I guess that is why getting a fresh set of eyes to look at things is helpful. In my case, I am just using an AI for those extra eyes. Either way, it works perfectly now. 
</p>
<p>
    I think I like this style of blogging for my 100 Days of Code journey. I feel I am retaining more and learning more deliberately than I have been. Overall, I am happy with how today went. 
</p>
<h1>
    Day 237
</h1>
<h3>
    Friday, 12 May, 2023
</h3>
<p>
    Today, I got a late start on coding. My day was a little crazy, but I still got my coding in. Starting off the day, I went back and looked at the code I got stuck on earlier in the week, and found I was a lot farther than I thought I was. The first thing I did was to write an answer to a question about how I would find both the intersection of two sets and the union of two sets, and express it in less than 30 seconds. 
</p>
<p>
    To find the union of two sets, I would create a for loop to iterate through both sets and add them to a third set. The built in functions of Python will handle the rest. To find the intersection of two sets, I would write a for loop to iterate through one set and check if each number is in the other, and from there, add any numbers that are found in both to a third set. 
</p>
<p>
    My next assignment wants me to take a series of two letter words, some of which have a word with mirrored letters in it. My task is to write a program in O(n) time that will find the word sets and print them to the screen. This is the part that left me struggling earlier this week. Coming back with fresh eyes, and a bit better of a foundation, makes a world of difference. After realizing, my first attempt was way too complex, and deleting the whole thing, I wrote an outline for what I need to do. 
</p>
<p>
    As I fleshed out the outline I built, I realized that I partially had a good idea in my first attempt. Break each word up into a list as I iterate through the set to then reverse it and check for its matching word. I just need to remember how to reverse a word. And a quick search on my friendly AI search engine got me the answer I needed. 
</p>
<p>
    I am very much enjoying this more detailed 100 Days of Code Journal. The process of being more detailed with my journal, is helping me remember what I have learned and incorporating it better into my future work. In the work I did yesterday, I ran into a problem trying to figure out how to make a combined if statement. I also ran into a problem with trying to create two separate continue statements, and thanks to my journal, I remembered what I did, and implemented that right away, the moment I saw a similar problem. 
</p>
<p>
    The last part of this assignment was write a response to a question, that I might be asked in an interview, to explain how I would find mirrored pairs of two letter words, assuming there are no duplicates. 
</p>
<p>
    I would first add each word into a set. Then, iterate through the set converting each word into a list using Pythons list functionality and use the pop command to reverse the word, then check if that reversed word is in the set. Then, after checking if it has already been printed, or if the reversed word and the word are the same, I would print the pair to the screen. 
</p>
<h1>
    Day 238
</h1>
<h3>
    Saturday, 13 May, 2023
</h3>
<p>
    Today, I started my lesson on maps, which are dictionaries in Python. For this lesson, I am going to solve five problems using the map data structure. The first is to take in both a word and its translation to build an English to German dictionary. The second is to take a CSV list containing generic census data including education status, pull out the education status and then tally up what degrees people reported having obtained. The third involves looking for anagrams. The fourth problem is to build a text-based maze. The fifth problem I will use the pip requests library to download data from the USGS website and then display the location and magnitudes of all earthquakes that day.  
</p>
<h3>
    Sunday, 14 May, 2023
</h3>
<p>
    Scheduled day off of coding
</p>
<h1>
    Day 239
</h1>
<h3>
    Monday, 15 May, 2023
</h3>
<p>
    For the translate problem, The requirements involve working with 2 functions, the names of which almost solve the problem for me. I will use one function to take both the English and German word in from the user, convert both words to lowercase, and then add them to the dictionary. The second function, will take a word from the user, convert it to lower case, check if it is in the dictionary, return "???" if it is not, and return the German translation if it is. 
</p>
<p>
    The second problem needs to be programmed to read the correct column, convert everything to lower case, then check if that degree option is already in the map (dictionary) and from there, either add it to the dictionary with a count of 1, or increase the count assigned as the value by one. 
</p>
<p>
    For the third problem, I will take the first word, use Python's built in list functionality, and convert the word into a list and use the pop function inside of a for loop to pull the last letter in the list out, effectively reversing the word. From there, I will check of the two words being tested are the same and return the appropriate value. 
</p>
<p>
    For the fourth problem, each possible grid location of the maze has a list containing if it is possible to move in each of the 4 possible directions. All I need to do, is to convert the direction the user would enter, into a number representing the index of the position, look up if it is possible to move in the direction they want to move, and then use a simple math function to update their position, and return the updated status or appropriate error code to the user. 
</p>
<p>
    As they have already provided the code needed to extract the data from the USGS website, I just need to teach the program how to pull the appropriate data from the downloaded table and from there, assign it to variables, and use a for loop to display the data to the screen. 
</p>
<h1>
    Day 240
</h1>
<h3>
    Tuesday, 16 May, 2023
</h3>
<p>
    I got the first problem solved nicely. It almost went exactly as planned. When I was first converting the string to lower case to ensure proper comparison, I initially forgot to put a parenthesis next to one of the lower commands.
</p>
<p>
    For the second problem, initially, I thought I needed to build a loop but then realized they already did that for me. From there, the only problem I ran into was accidentally putting the wrong index to pull the degrees out. 
</p>
<h1>
    Day 241
</h1>
<h3>
    Wednesday, 17 May, 2023
</h3>
<p>
    I realized that I misread the challenge for the 3rd problem. I thought it wanted me to simply see if two words are the same backwards and forwards. It actually wants me to see if they have the same letters in them regardless of case and in the same quantity. For example, cat and act are considered anagrams of each other and would need to return true but good and dog are not and would need to return false. 
</p>
<p>
    As I thought about the challenge, I realized that for this lesson we are focusing on dictionaries, so I asked myself how can I use a dictionary to solve this problem. From there, I realized that I can add each letter to a dictionary and count up the number of times each letter is used. From there, I can make sure that each letter is found in each word in the same quantities. 
</p>
<p>
    The case of each letter is not supposed to matter, so I will have to convert each string to lower case, which is easy through the lower() method. Spaces are supposed to be ignored. I remembered a method to remove whitespace, but could not remember the command (strip()), however, that would only remove from the ends of a string. I need something that would also remove from the middle, and with a bit more searching, I found remove. So, the solution would be to convert each string to lower case, replace all spaces with nothing (effectively deleting it). Then, I would iterate through each string, checking if each letter was in a dictionary, and either adding to the existing count or adding it to the dictionary with a count of 1. I would have a dictionary for each word I am comparing. Then I would need to use the letters in one word to check and see if each of the two dictionaries contain the same letters in the same quantities. 
</p>
<p>
    After fixing a few typos on my solution, I found it was crashing out the first time I ran into two strings that had characters that were not shared with each other. From there, I added a check to see if the character I was testing was in both dictionaries and that solved the problem. 
</p>
<h1>
    Day 242
</h1>
<h3>
    Thursday, 18 May, 2023
</h3>
<p>
    As I started working on the 4th challenge for this lesson, I ran across something that annoyed me and I am happy about that. I realized that with the most obvious way to solve the problem, I was essentially going to have to copy and paste a bunch of code. So, I started to rethink how I was going to solve the problem. I just need to learn a bit more about how classes in python work. 
</p>
<p>
    I figured out a solution. I'm technically not sure why there was a problem. For some reason, when I tried to implement a bit of the DRY principle and have the section of code that was outside of the individual functions, but when I included it into the individual functions, everything worked properly.
</p>
<p>
    While I did not like literally having to copy and past code into the multiple parts of my program, it worked, and I would rather have working code than pretty code. The only thing I can figure is that something about the possible directions was not updating properly each time. 
</p>
<h1>
    Day 243
</h1>
<h3>
    Friday, 19 May, 2023
</h3>
<p>
    Today, was a bit of study, but not in the normal way I have been. Today, I got a bit more focused on what kind of programming job I want. Just over a year ago, I started learning programming, but had not really focused in on where my niche would be. Today, I chose the role I want to focus on. I am going to become a mobile developer. a wonderfully helpful person on Twitter asked me a question that left me initially looking ignorant with the response I gave, and accurately so. @mnabilarta asked whether I was planning on native or hybrid. My initial response was to simply say whatever makes me more marketable. Now, that I have actually studied more on the topic, I realize that it is not that simple. In many cases, I realize that companies are going to prefer hybrid because of its lower development costs and easier process of upgrading the software. However, for those companies who want to have higher quality apps with more features and power accessible, then they will want to use native apps, and in many cases, I can see companies not really knowing the difference or what would be best for their needs. So, with that in mind, for me to learn both native and hybrid, would put me in a really valuable spot, at least if I can successfully master both methods. If I can't, then I think I would want to focus on native development, because after studying about the topic, I am pretty sure I know of a few apps that are built using the hybrid approach and they are massively annoying to work with. To be fair, I realize that those apps are only a small sampling of apps in a larger spectrum of companies and will not represent the greater whole. The reason I would choose native development over hybrid is really connected with a problem I have with the entire US business model, which is magnified by the all powerful idol god worshipped by so many, called the stock market. Too often companies are short sighted, and to me, with the admittedly limited knowledge I have on the topic, it feels shortsighted to build an app in a way that has so many limitations and restrictions to it. I guess, if you know your app will never get big enough or need enough resources to justify the native app development, then that might be one thing, but why would you plan to limit yourself in any way? Build your app, like you would build a proper business, build it in such a way that you could turn it over to someone else go on a 3 month cruise somewhere without internet, or phone service, and know that as long as you hired someone who actually wanted to do the job, you could come back and have everything working the way it should. 
    https://www.cleveroad.com/blog/native-vs-hybrid-app-development/
    https://www.indeed.com/career/mobile-developer/salaries
</p>
<h1>
    Day 244
</h1>
<h3>
    Saturday, 20 May, 2023
</h3>
<p>
    Today, I learned about the importance of networking when it comes to job hunting, downloaded the Android Studio, and solved the last problem for my dictionary assignment.
</p>
<p>
    Today, I downloaded and installed the Android developer studio. I found out that to develop apps for an Apple product, I need to have an Apple product. I don't know what I think of that. But, I should have enough to play with just learning to build an app for an Android. I also learned about the power of networking when getting jobs. Apparently more than 3 out of 4 jobs are never posted anywhere and are only filled through word of mouth. Which means that networking to find jobs is a powerful way to find a job. On Monday, I will start trying to learn how to use the Android Studio.
</p>
<p>
    Today, I solved the last of the problems for my dictionary assignment. In think for this problem, the hardest part was making sense of how the data was stored. My task was to pull data earthquake data from the USGS website, and print a list of the earthquakes from today. The data is stored in JSON format and was a dictionary of 4 data structures. The 1st was a dictionary containing general statistics. The 2nd was a list of some other statistics. The 4th was a dictionary containing a list of location details. And the 3rd (the one I needed to work with) was a list of dictionaries containing details about each earthquake. After figuring out how they had the data mapped, it was just a matter of creating a simple for loop to pull the data out and print it to the console. Overall, I learned a lot about understanding data structures. 
</p>
<h3>
    Sunday, 2a May, 2023
</h3>
<p>
Scheduled day off
</p>
<h1>
    Day 245
</h1>
<h3>
    Monday, 22 May, 2023
</h3>
<p>
    Today, I started working on my next assignment. It is on linked lists (In Python this is handled by the Deque). Today, was mostly a day of study. I did however get my me and 30 seconds written as part of starting to ask for referrals on my job hunt. The specific assignment I will be working on has mostly built a linked list manually I need to decipher what it is doing, finish out a few parts of it, and debug a few others.
</p>
<p>
    I am trying to get my first programming job. My ultimate goal is to become a mobile developer. I have experience using Python, JavaScript and C#. I also have experience with Object Oriented ideas like programming functions, classes, and data structures. What opportunities do you know of for someone with my skills? 
</p>
<h1>
    Day 246
</h1>
<h3>
    Tuesday, 23 May, 2023
</h3>
<p>
    Today, I got things set up to start getting job alerts, and started learning Kotlin. Along the way, I discovered that it really does get easier to learn new programming languages.
</p>
<p>
    Starting off the day, I dove more into job hunting skills, and learned about building a resume to suit the needs of the specific employer. I also got a job alert for mobile developer set up, with the specific goal of either updating my profile building a to do list of skills I will develop. I also started to go through Google's course on becoming an Android Developer. 
</p>
<p>
    Finishing the day, I went through the first 3 lessons of Google's intro to Kotlin and discovered that it really does get easier to learn new languages as you learn more. This is the 4th language I have learned, and while I am just getting started on Kotlin, it definitely feels easier to learn than the other languages I have learned. 
</p>
<h1>
    Day 247
</h1>
<h3>
    Wednesday, 24 May, 2023
</h3>
<p>
    Today, I finished the introduction to Kotlin lesson on developer.android.com. Tomorrow, I start on the lesson introducing Android Studio. Now, that I have 4 languages I have had significant exposure to, I can see many similarities between the different languages. I can also see their unique aspects and how they can be beneficial in different circumstances. I also reviewed the code for the next set of problems I am going to be solving. 
</p>
<h1>
    Day 248
</h1>
<h3>
    Thursday, 25 May, 2023
</h3>
<p>
    Today, I built my first Android app! Sure, it was basically a hello world app, but I got it built and even ran it on my own phone. 
</p>
<h1>
    Day 249
</h1>
<h3>
    Friday, 26 May, 2023
</h3>
<p>
    Today, I built a function to insert a new tail onto a linked list in Python, allowing for it to work properly if the list was either empty or had items previously in it. I also built code to remove the tail from a linked list either if the linked list only contained 1 item, or if the list had multiple items in it. 
</p>
<h1>
    Day 250
</h1>
<h3>
    Saturday, 27 May, 2023
</h3>
<p>
    Today, I solved the remaining three problems for my linked list assignment and in the process gained a powerful and deep appreciation for prebuilt lists and how much easier they are to work with. 
</p>
<p>
    The first of the three I solved had the challenge of taking and iterating through a manually built list, which can only be accessed by either starting at the head or the tail of the list, and then find the first node with a provided value, and then remove it. Initially, I tried to make sense of the code that was provided to see if I could make sense of everything, but that was unfruitful. My first several attempts were all epic failures that ended in one application crashing mess after another that even my handy dandy AI search engine could not make sense of. Eventually, I finally figured out how to iterate through the list, and then I had to figure out how to access the data. It only took 3 attempts (along with a little help from my handy AI search engine) to figure that out. 
</p>
<p>
    The goal of the second problem I solved was to replace all values in the list containing a provided value with another provided value. The work I put into solving the first problem, made the second one much quicker and easier to solve. I just had to modify the loop a bit to account for the different conditions, and then make sure I was properly accessing and updating the data, and that only took a few tries along with a little help from my hand AI search engine. 
</p>
<p>
    The goal of the last problem I solved was to print the list in reverse order. Between the work I did on the prior two problems, and the understanding I had developed of the program as a whole, I almost instantly knew what I needed to do, I just needed to find the right format to accomplish it with, and that only took a few quick tries to achieve. The biggest challenge was to get the output formatted properly and that involved realizing that the word yield which they put into the file was a hint not just a random word. From there, after I got a workable model and learned how the yield command worked, I refactored the code turning 8 lines into 2 that even made more sense to look at. 
</p>
<p>
    Overall, I am happy with how today went, I spent way more time than I planned to on this assignment but I did not want to take a shortcut. One of the major goals of the class is to learn how to problem solve and as that is a required skill needed to excel in programming, I want to master it.
</p>
<h3>
    Sunday, 28 May, 2023
</h3>
<p>
    Scheduled day off coding
</p>
<h1>
    Day 251
</h1>
<h3>
    Monday, 29 May, 2023
</h3>
<p>
    Today, I learned about recursion. Recursion is where the function calls itself. Good recursive functions will not be so simple that they can be solved with a simple for loop and will be designed to not run forever. In order to properly accomplish this we will need to define base cases, places that tell the program where to stop. We can also employ tools that will help the program speed up and not have to do repeated work. For example, you could build a dictionary to store the discovered parts of a fibonacci sequence, letting the program look up discovered variables in subsequent runs.
</p>
<p>
    Like the last several assignments I have completed, to complete this assignment, I will need to solve five problems. For these problems, I will need to use recursion along with anything else I have learned in this class. 
</p>
<p>
    The first problem involves being provided a number and then finding the sum of the squares of each number between that number and 1 inclusive, without using a loop. 
</p>
<p>
    The second problem involves being given a string of unique letters and a word length. The challenge is to find every permutation of the letters for that word length. For example if I were provided the letters "ABCD" and the number three, I would need to write a program using recursion to find all 24 combinations of three letters for those 4 letters. 
</p>
<p>
    The third problem involves being given a count of stairs and the option of either taking 1, 2, or 3 stairs at a time. The challenge is to use recursion to find all possible ways to climb the stairs. For this problem, they want you to write your code to be able to handle larger numbers like for example 100, which without first implementing a dictionary to remember prior solutions found, would cause python to stop working. 
</p>
<p>
    The forth problem, involves being given a string of characters that contain either a 1, 0, or *. The challenge I will have is to use recursion to produce all possible combinations of the string where each * is replaced by either a 1 or 0. For example, a string of 1*1 should produce 1001, 1011, 1101, and 1111. 
</p>
<p>
    The fifth problem is the one I am most excited to try to solve. We need to use recursion to help a computer find a way through a maze. 
</p>