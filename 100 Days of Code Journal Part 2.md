<h1>
    Day 200
</h1>
<h3>
    Thursday, 30 March, 2023
</h3>
<p>
    Today, I got a decent amount of progress on the last part of my programming final, and met with my group to demo what we had done. I was the only one who built my programs to be scalable beyond the basic requirements. 
</p>
<h1>
    Day 201
</h1>
<h3>
    Friday, 31 March, 2023
</h3>
<p>
    I finished my final! I successfully built 4 separate programs that demonstrated the principles of Abstraction, Encapsulation, Inheritance, and Polymorphism.
</p>
<h1>
    Day 202
</h1>
<h3>
    Saturday, 1 April, 2023
</h3>
<p>
    Today, I went back to some of the assignments I previously struggled with and found that I still have more to learn about encapsulation. 
</p>
<h3>
    Sunday, 2 April, 2023
</h3>
<p>
    Scheduled day off of coding. 
</p>
<h1>
    Day 203
</h1>
<h3>
    Monday, 3 April, 2023
</h3>
<p>
    Today I started studying the book Beginning Câ™¯ object-oriented programming by Dan Clark. While I am between semesters I am going to dive deeper into a few areas of Object Oriented Programming that I want a more solid foundation in before I get into Programming with Data Structures next semester. 
</p>
<h1>
    Day 204
</h1>
<h3>
    Tuesday, 4 April, 2023
</h3>
<p>
    For the class I just finished on programming with classes, they gave us a whole folder to run our C# programs out of. Between today, and yesterday, I have discovered why it is they chose that shortcut option. It is a lot of work to set up VS code to run C#. 
</p>
<h1>
    Day 205
</h1>
<h3>
    Wednesday, 5 April, 2023
</h3>
<p>
    Today, was a light day of coding. I studied a bit in my book and learned a bit more about algorithms. 
</p>
<h1>
    Day 206
</h1>
<h3>
    Thursday, 6 April, 2023
</h3>
<p>
    Today, I spent some more time in my OOP book and started learning how to use Visual Studio, instead of just VS Code. 
</p>
<h1>
    Day 207
</h1>
<h3>
    Friday, 7 April, 2023
</h3>
<p>
    Today, I dug deeper into Visual Studio. I am amazed at just how much more power it has than Visual Studio Code. I also read in my OOP book more. 
</p>
<h1>
    Day 208
</h1>
<h3>
    Saturday, 8 April, 2023
</h3>
<p>
    Today, I read more in my Object Oriented Programming book and explored more in Visual Studio. Most of my day was spent getting my next book ready to publish. It should be on Amazon in 72 hours.
</p>
<h3>
    Sunday, 9 April, 2023
</h3>
<p>
    Scheduled day off of coding
</p>
<h1>
    Day 209
</h1>
<h3>
    Monday, 10 April, 2023
</h3>
<p>
    Today, I read more in my OOP book, reviewed Python variables, strings, functions, loops, and classes, and then started going through the learning material for my next class.
</p>
<h1>
    Day 210
</h1>
<h3>
    Tuesday, 11 April, 2023
</h3>
<p>
    Today, I learned that the object portion of object oriented programming is specifically referring to a specific instance of a class. I also learned about big O notation and about thinking in terms of software efficiency. 
</p>
<h1>
    Day 211
</h1>
<h3>
    Wednesday, 12 April, 2023
</h3>
<p>
    Today, I got a quick overview of proper methods to review code, chaining, hashing, hashing functions, open addressing, sets, and sparse lists.I also learned about interfaces, abstract classes, sealed classes, and partial classes from my OOP book. 
</p>
<h1>
    Day 212
</h1>
<h3>
    Thursday, 13 April, 2023
</h3>
<p>
    Today, I got introduced to maps, linked lists, recursion, and trees. I also read more in my OOP book. 
</p>
<h1>
    Day 213
</h1>
<h3>
    Friday, 14 April, 2023
</h3>
<p>
    Today, I learned about aggregation and composition relationships in Object-Oriented Programming. A car has an aggregation relationship with its engine. The car and the engine are separate objects, and can both exist and function (in some manner) without the other, but they also join together to do more than they would by themselves. On the other hand, an order and an order item are both separate objects, but an order item cannot exist without the order, this is an example of a composition relationship. 
</p>
<h1>
    Day 214
</h1>
<h3>
    Saturday, 15 April, 2023
</h3>
<p>
    Today, I learned about and practiced with list comprehensions, methods to better plan out and refactor your code.
</p>
<h3>
    Sunday, 16 April, 2023
</h3>
<p>
    Scheduled day off from coding. 
</p>
<h1>
    Day 215
</h1>
<h3>
    Monday, 17 April, 2023
</h3>
<p>
    Today, I used list slicing to solve a problem for my data structures class. 
</p>
<h1>
    Day 216
</h1>
<h3>
    Tuesday, 18 April, 2023
</h3>
<p>
    Today, I studied about big O notation and about analyzing and practicing with algorithms. 
</p>
<h1>
    Day 217
</h1>
<h3>
    Wednesday, 19 April, 2023
</h3>
<p>
    Today, I started to analyze code for how it would translate in Big O notation. 
</p>
<h1>
    Day 218
</h1>
<h3>
    Thursday, 20 April, 2023
</h3>
<p>
    Today, I studied more about big O notation. I am not happy with my level of understanding about it, so I want to delve much deeper. 
</p>
<h1>
    Day 219
</h1>
<h3>
    Friday, 21 April, 2023
</h3>
<p>
    Today, I studied a bit more into Big O notation. It is slowly starting to make more sense. 
</p>
<h1>
    Day 220
</h1>
<h3>
    Saturday, 22 April, 2023
</h3>
<p>
    Today, I built two programs, one used a loop and then list comprehension to add divisors of a given number to a list. The other program dynamically pulled numbers from one of two lists to append them to a combined list, based on values in a third list. 
</p>
<h3>
    Sunday, 23 April, 2023
</h3>
<p>
    Scheduled day off from coding
</p>
<h1>
    Day 221
</h1>
<h3>
    Monday, 24 April, 2023
</h3>
<p>
    Today, I finished the chapter in my book on Big O notation and started to work on evaluating the assigned code for its big O notation. Last week, I was a little uneasy about my understanding of big O notation, now, I am happily feeling a lot more confident both in my understanding of big O and my ability to analyze code in general.
</p>
<h1>
    Day 222
</h1>
<h3>
    Wednesday, 25 April, 2023
</h3>
<p>
    Today, I finished studying big O notation. I am happy I dug in as much as I did to understand it. Thanks to the time I spent studying big O notation, not only do I have a better understanding of how to evaluate algorithms, I also have a better grasp of understanding code in general. Tomorrow, I will start learning about understanding code using reviews and stacks.
</p>
<h1>
    Day 223
</h1>
<h3>
    Wednesday, 26 April, 2023
</h3>
<p>
    Today, I practiced with analyzing code without running it. In this case, the code in question used the stack in different ways.
</p>
<h1>
    Day 224
</h1>
<h3>
    Thursday, 27 April, 2023
</h3>
<p>
    When I was first presented with the idea of manually reviewing code and mapping it out did not make sense at all. However, I am learning something new, and the people teaching me know a lot more than I currently do, so I put my full effort into the process. Now, I am glad I did, because I feel that reviewing code to the level I did fore this assignment made me a better programmer. 
</p>
<h1>
    Day 225
</h1>
<h3>
    Friday, 28 April, 2023
</h3>
<p>
    Today, I learned about testing code. I have had previous lessons in it, but there is still a lot to learn.
</p>
<h1>
    Day 226
</h1>
<h3>
    Saturday, 29 April, 2023
</h3>
<p>
    Today, I started analyzing code I was provided to find the bugs in it. In this case everything runs, it just does not provide the right results
</p>
<h3>
    Sunday, 30 April, 2023
</h3>
<p>
    Scheduled day off from coding.
</p>
<h1>
    Day 227
</h1>
<h3>
    Monday, 1 May, 2023
</h3>
<p>
    Today, I spent more time analyzing code for defects with the intention of fixing it. 
</p>
<h1>
    Day 228
</h1>
<h3>
    Tuesday, 2 May, 2023
</h3>
<p>
    Got two of the three defects fixed for the first program we were assigned to me. I found that instead of adding the names to the end, it was adding the names to the beginning of the queue.
</p>
<h1>
    Day 229
</h1>
<h3>
    Wednesday, 3 May, 2023
</h3>
<p>
    Today, I finished working on the last of my assignment working with queues. To accomplish this, I analyzed two programs provided to me, to figure out what they do. I used previously written test code in one of the programs and a description of what the program should do, to debug the code. And for the other program, I used a description of what the program should do, to write test code and then find and fix bugs in the code. 
</p>
<h1>
    Day 230
</h1>
<h3>
    Thursday, 4 May, 2023
</h3>
<p>
    Today, I studied about sets, and sparse lists. Tomorrow, I start a deep dive into programming with sets. 
</p>
<h1>
    Day 231
</h1>
<h3>
    Friday, 5 May, 2023
</h3>
<p>
    Today, analyzed the code I was given, the requirements I need to meet and started working on a plan for how to build the code I will be writing. I am going to be writing code to find matches in letters that might not be in the same order. 
</p>
<h1>
    Day 232
</h1>
<h3>
    Saturday, 6 May, 2023
</h3>
<p>
    Today, I wrote functions to find the intersection of two sets and join two sets without using any of the built in Python operators.
</p>
<h3>
    Sunday, 7 May, 2023
</h3>
<p>
    Scheduled day off from coding
</p>
<h1>
    Day 233
</h1>
<h3>
    Monday, 8 May, 2023
</h3>
<p>
    Today, I started working on writing code to compare check if the words given in a set, have any other words that contain all the same letters. For example, if and fi would be two words that contain the same letters and so they should be flagged by the program. 
</p>
<h1>
    Day 234
</h1>
<h3>
    Tuesday, 9 May, 2023
</h3>
<p>
    Today, I met with my group and felt underwhelmed. Instead of reasoning together, and truly working as a group, we basically did a individual programming assignment and quickly talked about it afterwards and even then only barely. I would have loved to have gained the insights of my group members, because then I would have learned how they think about how to solve problems and grown from it. I still learned something, so I can be grateful for that. I guess I would have just enjoyed more discussion. I guess I'll try again next week. 
</p>
<h1>
    Day 235
</h1>
<h3>
    Wednesday, 10 May, 2023
</h3>
<p>
    Today, I built a program in O(n) time that will check if there are any duplicate letters in a set of letters of n length. I started writing a program with goal of having it also run in O(n) time to find how many pairs of numbers can add up to 10. 
</p>
<h1>
    Day 236
</h1>
<h3>
    Thursday, 11 May, 2023
</h3>
<p>
    Today, I started working on a program to sort through a list of numbers trying to find pairs of numbers that can add up to 10. The list can be any size, and the numbers are all whole numbers, and can be positive or negative. The goal of the assignment I am working on is to build the program to run in O(n) time. 
</p>
<p>
    Building the program to run in O(n*n) time is easy, just create two for loops (one for each number you want to select) and it is done. Given our topic for the lesson, I know the solution will involve sets, but I am really not sure of how to approach this. So, the assignment in question suggests that I should spend no more than 5 minutes on this part before looking at their hint, so time to read a bit more. 
</p>
<p>
    Oh! That makes a lot of sense. Looking up a specific value in a set has an O(1) time. So, if you subtract each number from 10, that then gives you the number you need to add to it, in order to get 10. From there, you look for that number in the set, and you get a program performance of O(n), only having to loop through the program once to complete it.
</p>
<p>
    When writing my program, I forgot how to find a number in a set. A quick internet search, let me find that all I need to do is an if in statement. However, I did discover a problem with my code, as I am supposed to exclude duplicates from the numbers I found and my program does not.
</p>
<p>
    I initially tried to use a continue statement nested under an if statement, but that did not do what I wanted. From there, after struggling with the idea for a bit, I took my whole loop and asked my friendly ai search engine how I would alter the code to avoid printing out duplicate sets. At that point, I was finally able to figure out how to assemble the combined if statement I was wanting to do from the beginning. ... but for some reason it stopped the whole program from working altogether. 
</p>
<p>
    It took a bit, and finally asking my friendly AI search engine, but I figured out what I did. I had two separate sets I am using for my code, one to store the numbers in for analysis (numberSet), and one to use for checking if the number has already been printed (printedNumbers) and when I was trying to check if the number I was trying to find (numberToFind) was both in the numberSet and not in the printedNumbers, I instead asked if it was both in numberSet and not in numberSet. I feel blind that I missed that, in my multiple reviews of the code, but I guess that is why getting a fresh set of eyes to look at things is helpful. In my case, I am just using an AI for those extra eyes. Either way, it works perfectly now. 
</p>
<p>
    I think I like this style of blogging for my 100 Days of Code journey. I feel I am retaining more and learning more deliberately than I have been. Overall, I am happy with how today went. 
</p>
<h1>
    Day 237
</h1>
<h3>
    Friday, 12 May, 2023
</h3>
<p>
    Today, I got a late start on coding. My day was a little crazy, but I still got my coding in. Starting off the day, I went back and looked at the code I got stuck on earlier in the week, and found I was a lot farther than I thought I was. The first thing I did was to write an answer to a question about how I would find both the intersection of two sets and the union of two sets, and express it in less than 30 seconds. 
</p>
<p>
    To find the union of two sets, I would create a for loop to iterate through both sets and add them to a third set. The built in functions of Python will handle the rest. To find the intersection of two sets, I would write a for loop to iterate through one set and check if each number is in the other, and from there, add any numbers that are found in both to a third set. 
</p>
<p>
    My next assignment wants me to take a series of two letter words, some of which have a word with mirrored letters in it. My task is to write a program in O(n) time that will find the word sets and print them to the screen. This is the part that left me struggling earlier this week. Coming back with fresh eyes, and a bit better of a foundation, makes a world of difference. After realizing, my first attempt was way too complex, and deleting the whole thing, I wrote an outline for what I need to do. 
</p>
<p>
    As I fleshed out the outline I built, I realized that I partially had a good idea in my first attempt. Break each word up into a list as I iterate through the set to then reverse it and check for its matching word. I just need to remember how to reverse a word. And a quick search on my friendly AI search engine got me the answer I needed. 
</p>
<p>
    I am very much enjoying this more detailed 100 Days of Code Journal. The process of being more detailed with my journal, is helping me remember what I have learned and incorporating it better into my future work. In the work I did yesterday, I ran into a problem trying to figure out how to make a combined if statement. I also ran into a problem with trying to create two separate continue statements, and thanks to my journal, I remembered what I did, and implemented that right away, the moment I saw a similar problem. 
</p>
<p>
    The last part of this assignment was write a response to a question, that I might be asked in an interview, to explain how I would find mirrored pairs of two letter words, assuming there are no duplicates. 
</p>
<p>
    I would first add each word into a set. Then, iterate through the set converting each word into a list using Pythons list functionality and use the pop command to reverse the word, then check if that reversed word is in the set. Then, after checking if it has already been printed, or if the reversed word and the word are the same, I would print the pair to the screen. 
</p>
<h1>
    Day 238
</h1>
<h3>
    Saturday, 13 May, 2023
</h3>
<p>
    Today, I started my lesson on maps, which are dictionaries in Python. For this lesson, I am going to solve five problems using the map data structure. The first is to take in both a word and its translation to build an English to German dictionary. The second is to take a CSV list containing generic census data including education status, pull out the education status and then tally up what degrees people reported having obtained. The third involves looking for anagrams. The fourth problem is to build a text-based maze. The fifth problem I will use the pip requests library to download data from the USGS website and then display the location and magnitudes of all earthquakes that day.  
</p>
<h3>
    Sunday, 14 May, 2023
</h3>
<p>
    Scheduled day off of coding
</p>
<h1>
    Day 239
</h1>
<h3>
    Monday, 15 May, 2023
</h3>
<p>
    For the translate problem, The requirements involve working with 2 functions, the names of which almost solve the problem for me. I will use one function to take both the English and German word in from the user, convert both words to lowercase, and then add them to the dictionary. The second function, will take a word from the user, convert it to lower case, check if it is in the dictionary, return "???" if it is not, and return the German translation if it is. 
</p>
<p>
    The second problem needs to be programmed to read the correct column, convert everything to lower case, then check if that degree option is already in the map (dictionary) and from there, either add it to the dictionary with a count of 1, or increase the count assigned as the value by one. 
</p>
<p>
    For the third problem, I will take the first word, use Python's built in list functionality, and convert the word into a list and use the pop function inside of a for loop to pull the last letter in the list out, effectively reversing the word. From there, I will check of the two words being tested are the same and return the appropriate value. 
</p>
<p>
    For the fourth problem, each possible grid location of the maze has a list containing if it is possible to move in each of the 4 possible directions. All I need to do, is to convert the direction the user would enter, into a number representing the index of the position, look up if it is possible to move in the direction they want to move, and then use a simple math function to update their position, and return the updated status or appropriate error code to the user. 
</p>
<p>
    As they have already provided the code needed to extract the data from the USGS website, I just need to teach the program how to pull the appropriate data from the downloaded table and from there, assign it to variables, and use a for loop to display the data to the screen. 
</p>
<h1>
    Day 240
</h1>
<h3>
    Tuesday, 16 May, 2023
</h3>
<p>
    I got the first problem solved nicely. It almost went exactly as planned. When I was first converting the string to lower case to ensure proper comparison, I initially forgot to put a parenthesis next to one of the lower commands.
</p>
<p>
    For the second problem, initially, I thought I needed to build a loop but then realized they already did that for me. From there, the only problem I ran into was accidentally putting the wrong index to pull the degrees out. 
</p>
<h1>
    Day 241
</h1>
<h3>
    Wednesday, 17 May, 2023
</h3>
<p>
    I realized that I misread the challenge for the 3rd problem. I thought it wanted me to simply see if two words are the same backwards and forwards. It actually wants me to see if they have the same letters in them regardless of case and in the same quantity. For example, cat and act are considered anagrams of each other and would need to return true but good and dog are not and would need to return false. 
</p>
<p>
    As I thought about the challenge, I realized that for this lesson we are focusing on dictionaries, so I asked myself how can I use a dictionary to solve this problem. From there, I realized that I can add each letter to a dictionary and count up the number of times each letter is used. From there, I can make sure that each letter is found in each word in the same quantities. 
</p>
<p>
    The case of each letter is not supposed to matter, so I will have to convert each string to lower case, which is easy through the lower() method. Spaces are supposed to be ignored. I remembered a method to remove whitespace, but could not remember the command (strip()), however, that would only remove from the ends of a string. I need something that would also remove from the middle, and with a bit more searching, I found remove. So, the solution would be to convert each string to lower case, replace all spaces with nothing (effectively deleting it). Then, I would iterate through each string, checking if each letter was in a dictionary, and either adding to the existing count or adding it to the dictionary with a count of 1. I would have a dictionary for each word I am comparing. Then I would need to use the letters in one word to check and see if each of the two dictionaries contain the same letters in the same quantities. 
</p>
<p>
    After fixing a few typos on my solution, I found it was crashing out the first time I ran into two strings that had characters that were not shared with each other. From there, I added a check to see if the character I was testing was in both dictionaries and that solved the problem. 
</p>
<h1>
    Day 242
</h1>
<h3>
    Thursday, 18 May, 2023
</h3>
<p>
    As I started working on the 4th challenge for this lesson, I ran across something that annoyed me and I am happy about that. I realized that with the most obvious way to solve the problem, I was essentially going to have to copy and paste a bunch of code. So, I started to rethink how I was going to solve the problem. I just need to learn a bit more about how classes in python work. 
</p>
<p>
    I figured out a solution. I'm technically not sure why there was a problem. For some reason, when I tried to implement a bit of the DRY principle and have the section of code that was outside of the individual functions, but when I included it into the individual functions, everything worked properly.
</p>
<p>
    While I did not like literally having to copy and past code into the multiple parts of my program, it worked, and I would rather have working code than pretty code. The only thing I can figure is that something about the possible directions was not updating properly each time. 
</p>