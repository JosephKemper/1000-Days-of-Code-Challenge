<h1>
    Day 200
</h1>
<h3>
    Wednesday, 29 March, 2023
</h3>
<p>
    Today was an amazingly productive day. I finished my 3rd program for my final and got my last one started. Today, was also my 200th day of coding for my 100 days of code journey. 
</p>
<h1>
    Day 201
</h1>
<h3>
    Thursday, 30 March, 2023
</h3>
<p>
    Today, I got a decent amount of progress on the last part of my programming final, and met with my group to demo what we had done. I was the only one who built my programs to be scalable beyond the basic requirements. 
</p>
<h1>
    Day 202
</h1>
<h3>
    Friday, 31 March, 2023
</h3>
<p>
    I finished my final! I successfully built 4 separate programs that demonstrated the principles of Abstraction, Encapsulation, Inheritance, and Polymorphism.
</p>
<h1>
    Day 203
</h1>
<h3>
    Saturday, 1 April, 2023
</h3>
<p>
    Today, I went back to some of the assignments I previously struggled with and found that I still have more to learn about encapsulation. 
</p>
<h3>
    Sunday, 2 April, 2023
</h3>
<p>
    Scheduled day off of coding. 
</p>
<h1>
    Day 204
</h1>
<h3>
    Monday, 3 April, 2023
</h3>
<p>
    Today I started studying the book Beginning Câ™¯ object-oriented programming by Dan Clark. While I am between semesters I am going to dive deeper into a few areas of Object Oriented Programming that I want a more solid foundation in before I get into Programming with Data Structures next semester. 
</p>
<h1>
    Day 205
</h1>
<h3>
    Tuesday, 4 April, 2023
</h3>
<p>
    For the class I just finished on programming with classes, they gave us a whole folder to run our C# programs out of. Between today, and yesterday, I have discovered why it is they chose that shortcut option. It is a lot of work to set up VS code to run C#. 
</p>
<h1>
    Day 206
</h1>
<h3>
    Wednesday, 5 April, 2023
</h3>
<p>
    Today, was a light day of coding. I studied a bit in my book and learned a bit more about algorithms. 
</p>
<h1>
    Day 207
</h1>
<h3>
    Thursday, 6 April, 2023
</h3>
<p>
    Today, I spent some more time in my OOP book and started learning how to use Visual Studio, instead of just VS Code. 
</p>
<h1>
    Day 208
</h1>
<h3>
    Friday, 7 April, 2023
</h3>
<p>
    Today, I dug deeper into Visual Studio. I am amazed at just how much more power it has than Visual Studio Code. I also read in my OOP book more. 
</p>
<h1>
    Day 209
</h1>
<h3>
    Saturday, 8 April, 2023
</h3>
<p>
    Today, I read more in my Object Oriented Programming book and explored more in Visual Studio. Most of my day was spent getting my next book ready to publish. It should be on Amazon in 72 hours.
</p>
<h3>
    Sunday, 9 April, 2023
</h3>
<p>
    Scheduled day off of coding
</p>
<h1>
    Day 210
</h1>
<h3>
    Monday, 10 April, 2023
</h3>
<p>
    Today, I read more in my OOP book, reviewed Python variables, strings, functions, loops, and classes, and then started going through the learning material for my next class.
</p>
<h1>
    Day 211
</h1>
<h3>
    Tuesday, 11 April, 2023
</h3>
<p>
    Today, I learned that the object portion of object oriented programming is specifically referring to a specific instance of a class. I also learned about big O notation and about thinking in terms of software efficiency. 
</p>
<h1>
    Day 212
</h1>
<h3>
    Wednesday, 12 April, 2023
</h3>
<p>
    Today, I got a quick overview of proper methods to review code, chaining, hashing, hashing functions, open addressing, sets, and sparse lists.I also learned about interfaces, abstract classes, sealed classes, and partial classes from my OOP book. 
</p>
<h1>
    Day 213
</h1>
<h3>
    Thursday, 13 April, 2023
</h3>
<p>
    Today, I got introduced to maps, linked lists, recursion, and trees. I also read more in my OOP book. 
</p>
<h1>
    Day 214
</h1>
<h3>
    Friday, 14 April, 2023
</h3>
<p>
    Today, I learned about aggregation and composition relationships in Object-Oriented Programming. A car has an aggregation relationship with its engine. The car and the engine are separate objects, and can both exist and function (in some manner) without the other, but they also join together to do more than they would by themselves. On the other hand, an order and an order item are both separate objects, but an order item cannot exist without the order, this is an example of a composition relationship. 
</p>
<h1>
    Day 215
</h1>
<h3>
    Saturday, 15 April, 2023
</h3>
<p>
    Today, I learned about and practiced with list comprehensions, methods to better plan out and refactor your code.
</p>
<h3>
    Sunday, 16 April, 2023
</h3>
<p>
    Scheduled day off from coding. 
</p>
<h1>
    Day 216
</h1>
<h3>
    Monday, 17 April, 2023
</h3>
<p>
    Today, I used list slicing to solve a problem for my data structures class. 
</p>
<h1>
    Day 217
</h1>
<h3>
    Tuesday, 18 April, 2023
</h3>
<p>
    Today, I studied about big O notation and about analyzing and practicing with algorithms. 
</p>
<h1>
    Day 218
</h1>
<h3>
    Wednesday, 19 April, 2023
</h3>
<p>
    Today, I started to analyze code for how it would translate in Big O notation. 
</p>
<h1>
    Day 219
</h1>
<h3>
    Thursday, 20 April, 2023
</h3>
<p>
    Today, I studied more about big O notation. I am not happy with my level of understanding about it, so I want to delve much deeper. 
</p>
<h1>
    Day 220
</h1>
<h3>
    Friday, 21 April, 2023
</h3>
<p>
    Today, I studied a bit more into Big O notation. It is slowly starting to make more sense. 
</p>
<h1>
    Day 221
</h1>
<h3>
    Saturday, 22 April, 2023
</h3>
<p>
    Today, I built two programs, one used a loop and then list comprehension to add divisors of a given number to a list. The other program dynamically pulled numbers from one of two lists to append them to a combined list, based on values in a third list. 
</p>
<h3>
    Sunday, 23 April, 2023
</h3>
<p>
    Scheduled day off from coding
</p>
<h1>
    Day 222
</h1>
<h3>
    Monday, 24 April, 2023
</h3>
<p>
    Today, I finished the chapter in my book on Big O notation and started to work on evaluating the assigned code for its big O notation. Last week, I was a little uneasy about my understanding of big O notation, now, I am happily feeling a lot more confident both in my understanding of big O and my ability to analyze code in general.
</p>
<h1>
    Day 223
</h1>
<h3>
    Wednesday, 25 April, 2023
</h3>
<p>
    Today, I finished studying big O notation. I am happy I dug in as much as I did to understand it. Thanks to the time I spent studying big O notation, not only do I have a better understanding of how to evaluate algorithms, I also have a better grasp of understanding code in general. Tomorrow, I will start learning about understanding code using reviews and stacks.
</p>
<h1>
    Day 224
</h1>
<h3>
    Wednesday, 26 April, 2023
</h3>
<p>
    Today, I practiced with analyzing code without running it. In this case, the code in question used the stack in different ways.
</p>
<h1>
    Day 225
</h1>
<h3>
    Thursday, 27 April, 2023
</h3>
<p>
    When I was first presented with the idea of manually reviewing code and mapping it out did not make sense at all. However, I am learning something new, and the people teaching me know a lot more than I currently do, so I put my full effort into the process. Now, I am glad I did, because I feel that reviewing code to the level I did fore this assignment made me a better programmer. 
</p>
<h1>
    Day 226
</h1>
<h3>
    Friday, 28 April, 2023
</h3>
<p>
    Today, I learned about testing code. I have had previous lessons in it, but there is still a lot to learn.
</p>
<h1>
    Day 227
</h1>
<h3>
    Saturday, 29 April, 2023
</h3>
<p>
    Today, I started analyzing code I was provided to find the bugs in it. In this case everything runs, it just does not provide the right results
</p>
<h3>
    Sunday, 30 April, 2023
</h3>
<p>
    Scheduled day off from coding.
</p>
<h1>
    Day 228
</h1>
<h3>
    Monday, 1 May, 2023
</h3>
<p>
    Today, I spent more time analyzing code for defects with the intention of fixing it. 
</p>
<h1>
    Day 229
</h1>
<h3>
    Tuesday, 2 May, 2023
</h3>
<p>
    Got two of the three defects fixed for the first program we were assigned to me. I found that instead of adding the names to the end, it was adding the names to the beginning of the queue.
</p>
<h1>
    Day 230
</h1>
<h3>
    Wednesday, 3 May, 2023
</h3>
<p>
    Today, I finished working on the last of my assignment working with queues. To accomplish this, I analyzed two programs provided to me, to figure out what they do. I used previously written test code in one of the programs and a description of what the program should do, to debug the code. And for the other program, I used a description of what the program should do, to write test code and then find and fix bugs in the code. 
</p>
<h1>
    Day 231
</h1>
<h3>
    Thursday, 4 May, 2023
</h3>
<p>
    Today, I studied about sets, and sparse lists. Tomorrow, I start a deep dive into programming with sets. 
</p>
<h1>
    Day 232
</h1>
<h3>
    Friday, 5 May, 2023
</h3>
<p>
    Today, analyzed the code I was given, the requirements I need to meet and started working on a plan for how to build the code I will be writing. I am going to be writing code to find matches in letters that might not be in the same order. 
</p>
<h1>
    Day 233
</h1>
<h3>
    Saturday, 6 May, 2023
</h3>
<p>
    Today, I wrote functions to find the intersection of two sets and join two sets without using any of the built in Python operators.
</p>
<h3>
    Sunday, 7 May, 2023
</h3>
<p>
    Scheduled day off from coding
</p>
<h1>
    Day 234
</h1>
<h3>
    Monday, 8 May, 2023
</h3>
<p>
    Today, I started working on writing code to compare check if the words given in a set, have any other words that contain all the same letters. For example, if and fi would be two words that contain the same letters and so they should be flagged by the program. 
</p>
<h1>
    Day 235
</h1>
<h3>
    Tuesday, 9 May, 2023
</h3>
<p>
    Today, I met with my group and felt underwhelmed. Instead of reasoning together, and truly working as a group, we basically did a individual programming assignment and quickly talked about it afterwards and even then only barely. I would have loved to have gained the insights of my group members, because then I would have learned how they think about how to solve problems and grown from it. I still learned something, so I can be grateful for that. I guess I would have just enjoyed more discussion. I guess I'll try again next week. 
</p>
<h1>
    Day 236
</h1>
<h3>
    Wednesday, 10 May, 2023
</h3>
<p>
    Today, I built a program in O(n) time that will check if there are any duplicate letters in a set of letters of n length. I started writing a program with goal of having it also run in O(n) time to find how many pairs of numbers can add up to 10. 
</p>
<h1>
    Day 237
</h1>
<h3>
    Thursday, 11 May, 2023
</h3>
<p>
    Today, I started working on a program to sort through a list of numbers trying to find pairs of numbers that can add up to 10. The list can be any size, and the numbers are all whole numbers, and can be positive or negative. The goal of the assignment I am working on is to build the program to run in O(n) time. 
</p>
<p>
    Building the program to run in O(n*n) time is easy, just create two for loops (one for each number you want to select) and it is done. Given our topic for the lesson, I know the solution will involve sets, but I am really not sure of how to approach this. So, the assignment in question suggests that I should spend no more than 5 minutes on this part before looking at their hint, so time to read a bit more. 
</p>
<p>
    Oh! That makes a lot of sense. Looking up a specific value in a set has an O(1) time. So, if you subtract each number from 10, that then gives you the number you need to add to it, in order to get 10. From there, you look for that number in the set, and you get a program performance of O(n), only having to loop through the program once to complete it.
</p>
<p>
    When writing my program, I forgot how to find a number in a set. A quick internet search, let me find that all I need to do is an if in statement. However, I did discover a problem with my code, as I am supposed to exclude duplicates from the numbers I found and my program does not.
</p>
<p>
    I initially tried to use a continue statement nested under an if statement, but that did not do what I wanted. From there, after struggling with the idea for a bit, I took my whole loop and asked my friendly ai search engine how I would alter the code to avoid printing out duplicate sets. At that point, I was finally able to figure out how to assemble the combined if statement I was wanting to do from the beginning. ... but for some reason it stopped the whole program from working altogether. 
</p>
<p>
    It took a bit, and finally asking my friendly AI search engine, but I figured out what I did. I had two separate sets I am using for my code, one to store the numbers in for analysis (numberSet), and one to use for checking if the number has already been printed (printedNumbers) and when I was trying to check if the number I was trying to find (numberToFind) was both in the numberSet and not in the printedNumbers, I instead asked if it was both in numberSet and not in numberSet. I feel blind that I missed that, in my multiple reviews of the code, but I guess that is why getting a fresh set of eyes to look at things is helpful. In my case, I am just using an AI for those extra eyes. Either way, it works perfectly now. 
</p>
<p>
    I think I like this style of blogging for my 100 Days of Code journey. I feel I am retaining more and learning more deliberately than I have been. Overall, I am happy with how today went. 
</p>
<h1>
    Day 238
</h1>
<h3>
    Friday, 12 May, 2023
</h3>
<p>
    Today, I got a late start on coding. My day was a little crazy, but I still got my coding in. Starting off the day, I went back and looked at the code I got stuck on earlier in the week, and found I was a lot farther than I thought I was. The first thing I did was to write an answer to a question about how I would find both the intersection of two sets and the union of two sets, and express it in less than 30 seconds. 
</p>
<p>
    To find the union of two sets, I would create a for loop to iterate through both sets and add them to a third set. The built in functions of Python will handle the rest. To find the intersection of two sets, I would write a for loop to iterate through one set and check if each number is in the other, and from there, add any numbers that are found in both to a third set. 
</p>
<p>
    My next assignment wants me to take a series of two letter words, some of which have a word with mirrored letters in it. My task is to write a program in O(n) time that will find the word sets and print them to the screen. This is the part that left me struggling earlier this week. Coming back with fresh eyes, and a bit better of a foundation, makes a world of difference. After realizing, my first attempt was way too complex, and deleting the whole thing, I wrote an outline for what I need to do. 
</p>
<p>
    As I fleshed out the outline I built, I realized that I partially had a good idea in my first attempt. Break each word up into a list as I iterate through the set to then reverse it and check for its matching word. I just need to remember how to reverse a word. And a quick search on my friendly AI search engine got me the answer I needed. 
</p>
<p>
    I am very much enjoying this more detailed 100 Days of Code Journal. The process of being more detailed with my journal, is helping me remember what I have learned and incorporating it better into my future work. In the work I did yesterday, I ran into a problem trying to figure out how to make a combined if statement. I also ran into a problem with trying to create two separate continue statements, and thanks to my journal, I remembered what I did, and implemented that right away, the moment I saw a similar problem. 
</p>
<p>
    The last part of this assignment was write a response to a question, that I might be asked in an interview, to explain how I would find mirrored pairs of two letter words, assuming there are no duplicates. 
</p>
<p>
    I would first add each word into a set. Then, iterate through the set converting each word into a list using Pythons list functionality and use the pop command to reverse the word, then check if that reversed word is in the set. Then, after checking if it has already been printed, or if the reversed word and the word are the same, I would print the pair to the screen. 
</p>
<h1>
    Day 239
</h1>
<h3>
    Saturday, 13 May, 2023
</h3>
<p>
    Today, I started my lesson on maps, which are dictionaries in Python. For this lesson, I am going to solve five problems using the map data structure. The first is to take in both a word and its translation to build an English to German dictionary. The second is to take a CSV list containing generic census data including education status, pull out the education status and then tally up what degrees people reported having obtained. The third involves looking for anagrams. The fourth problem is to build a text-based maze. The fifth problem I will use the pip requests library to download data from the USGS website and then display the location and magnitudes of all earthquakes that day.  
</p>
<h3>
    Sunday, 14 May, 2023
</h3>
<p>
    Scheduled day off of coding
</p>
<h1>
    Day 240
</h1>
<h3>
    Monday, 15 May, 2023
</h3>
<p>
    For the translate problem, The requirements involve working with 2 functions, the names of which almost solve the problem for me. I will use one function to take both the English and German word in from the user, convert both words to lowercase, and then add them to the dictionary. The second function, will take a word from the user, convert it to lower case, check if it is in the dictionary, return "???" if it is not, and return the German translation if it is. 
</p>
<p>
    The second problem needs to be programmed to read the correct column, convert everything to lower case, then check if that degree option is already in the map (dictionary) and from there, either add it to the dictionary with a count of 1, or increase the count assigned as the value by one. 
</p>
<p>
    For the third problem, I will take the first word, use Python's built in list functionality, and convert the word into a list and use the pop function inside of a for loop to pull the last letter in the list out, effectively reversing the word. From there, I will check of the two words being tested are the same and return the appropriate value. 
</p>
<p>
    For the fourth problem, each possible grid location of the maze has a list containing if it is possible to move in each of the 4 possible directions. All I need to do, is to convert the direction the user would enter, into a number representing the index of the position, look up if it is possible to move in the direction they want to move, and then use a simple math function to update their position, and return the updated status or appropriate error code to the user. 
</p>
<p>
    As they have already provided the code needed to extract the data from the USGS website, I just need to teach the program how to pull the appropriate data from the downloaded table and from there, assign it to variables, and use a for loop to display the data to the screen. 
</p>
<h1>
    Day 241
</h1>
<h3>
    Tuesday, 16 May, 2023
</h3>
<p>
    I got the first problem solved nicely. It almost went exactly as planned. When I was first converting the string to lower case to ensure proper comparison, I initially forgot to put a parenthesis next to one of the lower commands.
</p>
<p>
    For the second problem, initially, I thought I needed to build a loop but then realized they already did that for me. From there, the only problem I ran into was accidentally putting the wrong index to pull the degrees out. 
</p>
<h1>
    Day 242
</h1>
<h3>
    Wednesday, 17 May, 2023
</h3>
<p>
    I realized that I misread the challenge for the 3rd problem. I thought it wanted me to simply see if two words are the same backwards and forwards. It actually wants me to see if they have the same letters in them regardless of case and in the same quantity. For example, cat and act are considered anagrams of each other and would need to return true but good and dog are not and would need to return false. 
</p>
<p>
    As I thought about the challenge, I realized that for this lesson we are focusing on dictionaries, so I asked myself how can I use a dictionary to solve this problem. From there, I realized that I can add each letter to a dictionary and count up the number of times each letter is used. From there, I can make sure that each letter is found in each word in the same quantities. 
</p>
<p>
    The case of each letter is not supposed to matter, so I will have to convert each string to lower case, which is easy through the lower() method. Spaces are supposed to be ignored. I remembered a method to remove whitespace, but could not remember the command (strip()), however, that would only remove from the ends of a string. I need something that would also remove from the middle, and with a bit more searching, I found remove. So, the solution would be to convert each string to lower case, replace all spaces with nothing (effectively deleting it). Then, I would iterate through each string, checking if each letter was in a dictionary, and either adding to the existing count or adding it to the dictionary with a count of 1. I would have a dictionary for each word I am comparing. Then I would need to use the letters in one word to check and see if each of the two dictionaries contain the same letters in the same quantities. 
</p>
<p>
    After fixing a few typos on my solution, I found it was crashing out the first time I ran into two strings that had characters that were not shared with each other. From there, I added a check to see if the character I was testing was in both dictionaries and that solved the problem. 
</p>
<h1>
    Day 243
</h1>
<h3>
    Thursday, 18 May, 2023
</h3>
<p>
    As I started working on the 4th challenge for this lesson, I ran across something that annoyed me and I am happy about that. I realized that with the most obvious way to solve the problem, I was essentially going to have to copy and paste a bunch of code. So, I started to rethink how I was going to solve the problem. I just need to learn a bit more about how classes in python work. 
</p>
<p>
    I figured out a solution. I'm technically not sure why there was a problem. For some reason, when I tried to implement a bit of the DRY principle and have the section of code that was outside of the individual functions, but when I included it into the individual functions, everything worked properly.
</p>
<p>
    While I did not like literally having to copy and past code into the multiple parts of my program, it worked, and I would rather have working code than pretty code. The only thing I can figure is that something about the possible directions was not updating properly each time. 
</p>
<h1>
    Day 244
</h1>
<h3>
    Friday, 19 May, 2023
</h3>
<p>
    Today, was a bit of study, but not in the normal way I have been. Today, I got a bit more focused on what kind of programming job I want. Just over a year ago, I started learning programming, but had not really focused in on where my niche would be. Today, I chose the role I want to focus on. I am going to become a mobile developer. a wonderfully helpful person on Twitter asked me a question that left me initially looking ignorant with the response I gave, and accurately so. @mnabilarta asked whether I was planning on native or hybrid. My initial response was to simply say whatever makes me more marketable. Now, that I have actually studied more on the topic, I realize that it is not that simple. In many cases, I realize that companies are going to prefer hybrid because of its lower development costs and easier process of upgrading the software. However, for those companies who want to have higher quality apps with more features and power accessible, then they will want to use native apps, and in many cases, I can see companies not really knowing the difference or what would be best for their needs. So, with that in mind, for me to learn both native and hybrid, would put me in a really valuable spot, at least if I can successfully master both methods. If I can't, then I think I would want to focus on native development, because after studying about the topic, I am pretty sure I know of a few apps that are built using the hybrid approach and they are massively annoying to work with. To be fair, I realize that those apps are only a small sampling of apps in a larger spectrum of companies and will not represent the greater whole. The reason I would choose native development over hybrid is really connected with a problem I have with the entire US business model, which is magnified by the all powerful idol god worshipped by so many, called the stock market. Too often companies are short sighted, and to me, with the admittedly limited knowledge I have on the topic, it feels shortsighted to build an app in a way that has so many limitations and restrictions to it. I guess, if you know your app will never get big enough or need enough resources to justify the native app development, then that might be one thing, but why would you plan to limit yourself in any way? Build your app, like you would build a proper business, build it in such a way that you could turn it over to someone else go on a 3 month cruise somewhere without internet, or phone service, and know that as long as you hired someone who actually wanted to do the job, you could come back and have everything working the way it should. 
    https://www.cleveroad.com/blog/native-vs-hybrid-app-development/
    https://www.indeed.com/career/mobile-developer/salaries
</p>
<h1>
    Day 245
</h1>
<h3>
    Saturday, 20 May, 2023
</h3>
<p>
    Today, I learned about the importance of networking when it comes to job hunting, downloaded the Android Studio, and solved the last problem for my dictionary assignment.
</p>
<p>
    Today, I downloaded and installed the Android developer studio. I found out that to develop apps for an Apple product, I need to have an Apple product. I don't know what I think of that. But, I should have enough to play with just learning to build an app for an Android. I also learned about the power of networking when getting jobs. Apparently more than 3 out of 4 jobs are never posted anywhere and are only filled through word of mouth. Which means that networking to find jobs is a powerful way to find a job. On Monday, I will start trying to learn how to use the Android Studio.
</p>
<p>
    Today, I solved the last of the problems for my dictionary assignment. In think for this problem, the hardest part was making sense of how the data was stored. My task was to pull data earthquake data from the USGS website, and print a list of the earthquakes from today. The data is stored in JSON format and was a dictionary of 4 data structures. The 1st was a dictionary containing general statistics. The 2nd was a list of some other statistics. The 4th was a dictionary containing a list of location details. And the 3rd (the one I needed to work with) was a list of dictionaries containing details about each earthquake. After figuring out how they had the data mapped, it was just a matter of creating a simple for loop to pull the data out and print it to the console. Overall, I learned a lot about understanding data structures. 
</p>
<h3>
    Sunday, 21 May, 2023
</h3>
<p>
Scheduled day off
</p>
<h1>
    Day 246
</h1>
<h3>
    Monday, 22 May, 2023
</h3>
<p>
    Today, I started working on my next assignment. It is on linked lists (In Python this is handled by the Deque). Today, was mostly a day of study. I did however get my me and 30 seconds written as part of starting to ask for referrals on my job hunt. The specific assignment I will be working on has mostly built a linked list manually I need to decipher what it is doing, finish out a few parts of it, and debug a few others.
</p>
<p>
    I am trying to get my first programming job. My ultimate goal is to become a mobile developer. I have experience using Python, JavaScript and C#. I also have experience with Object Oriented ideas like programming functions, classes, and data structures. What opportunities do you know of for someone with my skills? 
</p>
<h1>
    Day 247
</h1>
<h3>
    Tuesday, 23 May, 2023
</h3>
<p>
    Today, I got things set up to start getting job alerts, and started learning Kotlin. Along the way, I discovered that it really does get easier to learn new programming languages.
</p>
<p>
    Starting off the day, I dove more into job hunting skills, and learned about building a resume to suit the needs of the specific employer. I also got a job alert for mobile developer set up, with the specific goal of either updating my profile building a to do list of skills I will develop. I also started to go through Google's course on becoming an Android Developer. 
</p>
<p>
    Finishing the day, I went through the first 3 lessons of Google's intro to Kotlin and discovered that it really does get easier to learn new languages as you learn more. This is the 4th language I have learned, and while I am just getting started on Kotlin, it definitely feels easier to learn than the other languages I have learned. 
</p>
<h1>
    Day 248
</h1>
<h3>
    Wednesday, 24 May, 2023
</h3>
<p>
    Today, I finished the introduction to Kotlin lesson on developer.android.com. Tomorrow, I start on the lesson introducing Android Studio. Now, that I have 4 languages I have had significant exposure to, I can see many similarities between the different languages. I can also see their unique aspects and how they can be beneficial in different circumstances. I also reviewed the code for the next set of problems I am going to be solving. 
</p>
<h1>
    Day 249
</h1>
<h3>
    Thursday, 25 May, 2023
</h3>
<p>
    Today, I built my first Android app! Sure, it was basically a hello world app, but I got it built and even ran it on my own phone. 
</p>
<h1>
    Day 250
</h1>
<h3>
    Friday, 26 May, 2023
</h3>
<p>
    Today, I built a function to insert a new tail onto a linked list in Python, allowing for it to work properly if the list was either empty or had items previously in it. I also built code to remove the tail from a linked list either if the linked list only contained 1 item, or if the list had multiple items in it. 
</p>
<h1>
    Day 251
</h1>
<h3>
    Saturday, 27 May, 2023
</h3>
<p>
    Today, I solved the remaining three problems for my linked list assignment and in the process gained a powerful and deep appreciation for prebuilt lists and how much easier they are to work with. 
</p>
<p>
    The first of the three I solved had the challenge of taking and iterating through a manually built list, which can only be accessed by either starting at the head or the tail of the list, and then find the first node with a provided value, and then remove it. Initially, I tried to make sense of the code that was provided to see if I could make sense of everything, but that was unfruitful. My first several attempts were all epic failures that ended in one application crashing mess after another that even my handy dandy AI search engine could not make sense of. Eventually, I finally figured out how to iterate through the list, and then I had to figure out how to access the data. It only took 3 attempts (along with a little help from my handy AI search engine) to figure that out. 
</p>
<p>
    The goal of the second problem I solved was to replace all values in the list containing a provided value with another provided value. The work I put into solving the first problem, made the second one much quicker and easier to solve. I just had to modify the loop a bit to account for the different conditions, and then make sure I was properly accessing and updating the data, and that only took a few tries along with a little help from my hand AI search engine. 
</p>
<p>
    The goal of the last problem I solved was to print the list in reverse order. Between the work I did on the prior two problems, and the understanding I had developed of the program as a whole, I almost instantly knew what I needed to do, I just needed to find the right format to accomplish it with, and that only took a few quick tries to achieve. The biggest challenge was to get the output formatted properly and that involved realizing that the word yield which they put into the file was a hint not just a random word. From there, after I got a workable model and learned how the yield command worked, I refactored the code turning 8 lines into 2 that even made more sense to look at. 
</p>
<p>
    Overall, I am happy with how today went, I spent way more time than I planned to on this assignment but I did not want to take a shortcut. One of the major goals of the class is to learn how to problem solve and as that is a required skill needed to excel in programming, I want to master it.
</p>
<h3>
    Sunday, 28 May, 2023
</h3>
<p>
    Scheduled day off coding
</p>
<h1>
    Day 252
</h1>
<h3>
    Monday, 29 May, 2023
</h3>
<p>
    Today, I learned about recursion. Recursion is where the function calls itself. Good recursive functions will not be so simple that they can be solved with a simple for loop and will be designed to not run forever. In order to properly accomplish this we will need to define base cases, places that tell the program where to stop. We can also employ tools that will help the program speed up and not have to do repeated work. For example, you could build a dictionary to store the discovered parts of a fibonacci sequence, letting the program look up discovered variables in subsequent runs.
</p>
<p>
    Like the last several assignments I have completed, to complete this assignment, I will need to solve five problems. For these problems, I will need to use recursion along with anything else I have learned in this class.
</p>
<p>
    The first problem involves being provided a number and then finding the sum of the squares of each number between that number and 1 inclusive, without using a loop.  
</p>
<p>
    The second problem involves being given a string of unique letters and a word length. The challenge is to find every permutation of the letters for that word length. For example, if I were provided the letters "ABCD" and the number three, I would need to write a program using recursion to find all 24 combinations of three letters for those 4 letters.  
</p>
<p>
    The third problem involves being given a number of stairs and the option of either taking 1, 2, or 3 stairs at a time. The challenge is to use recursion to find all possible ways to climb the stairs. For this problem, they want you to write your code to be able to handle larger numbers like for example 100, which without first implementing a dictionary to remember prior solutions found, would cause python to stop working.  
</p>
<p>
    The fourth problem involves being given a string of characters that contain either a 1, 0, or *. The challenge I will have is to use recursion to produce all possible combinations of the string where each * is replaced by either a 1 or 0. For example, a string of 1*1 should produce 1001, 1011, 1101, and 1111. 
</p>
<p>
    The fifth problem is the one I am most excited to try to solve. We need to use recursion to help a computer find a way through a maze. 
</p>
<h1>
    Day 253
</h1>
<h3>
    Tuesday, 30 May, 2023
</h3>
<p>
    Today, I wrote code to find the solution to the first problem of my recursion assignment. The goal of the problem was to find the sum of squares for a series of numbers that would start with 1, and go to n, when provided with the number n. So, if I were provided with the number 3, I would find the sum of the squares of 1, 2, and 3. To achieve this, I need to use recursion, and cannot use a loop. Initially I struggled with this problem for a bit, then I finally figured out how to apply the similar problem they gave in the study material. 
</p>
<code>
    def factorial(n):
    if n <= 1:
        return 1  # 1! = 1 (no recursion)
    else:
        return n * factorial(n-1)  # n! = n * (n-1)!
</code>
<p>
    It took a bit of playing around to understand what that code was doing along with a few other tries before I realized how I could use that principle to solve my problem. Instead of multiplying n by a call to the function including n minus 1, I would multiply n by n and then add a call to the function including n - 1. At that point, the function would queue up the who series and add them all to 1. 
</p>
<h1>
    Day 254
</h1>
<h3>
    Wednesday, 31 May, 2023
</h3>
<p>
    Today, I learned about the power of understanding code. I solved the second problem for my recursive programming assignment and the only code I actually wrote to do it just involved editing two lines of code from the study material. Initially, when I first started trying to figure out the problem, they seemed like two different problems that just happened to involve similar concepts, but then as I dove deeper, I realized that the only difference was that the one I was trying to solve simply had an extra condition added. The problem I was trying to solve was to take and find all permutations of a string of letters but only find them to a length provided after the code starts running. The problem they demoed in the reading material was to find all permutations of a string of letters based on how long the string was. I am beginning to see why programmers are sometimes referred to as professional Googlers. 
</p>
<h1>
    Day 255
</h1>
<h3>
    Thursday, 1 June, 2023
</h3>
<p>
    I'm almost getting worried. This problem was too easy, but I double checked the results so... Today, I solved the 3rd problem. My challenge was to implement code to remember what had previously been found in a function built to find all possible combinations of steps that could be taken, assuming you could take either 1, 2, or 3 steps at a time. Again with this problem, I found that the reading material almost perfectly spelled out the solution. I just had to adjust one variable name and then add 4 lines of code, and modify one more to override the recursive function call. 
</p>
<h1>
    Day 256
</h1>
<h3>
    Friday, 2 June, 2023
</h3>
<p>
    Today, I started the process of mapping out the next problem I need to solve. This one is happily a lot more difficult. 
</p>
<h1>
    Day 257
</h1>
<h3>
    Friday, 2 June, 2023
</h3>
<p>
    The forth problem I am trying to solve involves taking a string of characters consisting of 1, 0, or *, and produce a series of outputs containing every possible combination of 1, and 0 digits in place of the *. I struggled with this yesterday ... a lot. I couldn't even figure out a basic strategy to the problem. Today, I started reviewing old lessons I've already gone through to see what I can find to help. The first lesson I went through, which was the first lesson of the semester, gave an overview of how to solve problems and the first step was to understand the problem. So, I opened up OneNote and started writing down more about the problem to try to understand what I am trying to achieve. If my program were to be fed this string 1*1, then it should put out both 111, and 101. If it were fed this string 1**1, it should put out 1111, 1001, 1011, and 1101. As I wrote that, I realized that the problem is far simpler than I realized, essentially, I am trying to take a string and replace each * with both a 1 and a 0. This means that, my outcomes will be 2 to the power of n, where n is equal to the number of * symbols in the string. As we are studying recursion, my solution needs to involve the use of recursion. 
</p>
<p>
    After a few more notes jotted down in OneNote and some time spent pacing and talking the problem out, I think I have a strategy to solve the problem with. I will have two different lists that I will be working with. One, will contain a list of manipulated strings which will essentially act as a queue, it is where I will store the strings I have started to replace characters in. The other will be used to break those strings up into a manipulatable list. For the program, I will pull the first item out of the list check if there is a * in the string. If there is, it will assign that string to 2 different variables. One will be used to replace the first * found with a 1 and the other will be used to replace the first * found with a 0. If there is not any * characters in the string, it will remove that string from the list, and print it to the console. If there are any items left in the list, it will call the function again to continue cycling through the rest of the list. 
</p>
<p>
    In the end, other than needing to fix a few problems with improperly built loops, and organize things a bit better, my solution worked perfectly. I don't know if it is the most efficient solution, but it is the best solution I could figure out while using recursion. 
</p>
<h3>
    Sunday, 4 June, 2023
</h3>
<p>
    Scheduled Day off Coding
</p>
<h1>
    Day 258
</h1>
<h3>
    Monday, 5 June, 2023
</h3>
<p>
    Today, I spent some time studying the next problem I need to solve. I still have a bit more work to go before I will be ready to move forward. 
</p>
<h1>
    Day 259
</h1>
<h3>
    Tuesday, 6 June, 2023
</h3>
<p>
    I got a possible solution to the problem I am working on figured out and even have a first draft written. It is just not very efficient, to the extent that Python forces it to stop it before it completes. I think I know how to fix it, and will try to implement that tomorrow. 
</p>
<h1>
    Day 260
</h1>
<h3>
    Wednesday, 7 June, 2023
</h3>
<p>
    Today, I finished writing a function to teach a computer how to solve a maze. The provided tests for the program gave two different mazes to try to find my way through, one was a smaller maze with two possible paths. I only found one of them. The other was a larger maze that had only one possible path and many dead end paths. One of the conditions to solve the problem was that we needed to use recursion. My first attempt at a solution hit the recursion limit in python because it was trying to use recursion to make any move. From there, I refactored the code to only use recursion if it hit a dead end. However, even with that change I still hit the recursion limit. From there, I realized that the reason for the problem was that the code would slowly add each square along a dead end path to the list I was using to track dead ends. So, I refactored the code again, and added the ability to track the last time the program made a choice between two paths, and specifically track the first square along a path. From there, I enabled to program to mark that first square as a dead end instead of having to go through the whole path. 
</p>
<h1>
    Day 261
</h1>
<h3>
    Thursday, 8 June, 2023
</h3>
<p>
    Today, I started my lesson on binary search trees. For this lesson, we are given a partially implemented binary search tree. There are 5 problems we need to solve. The 1st problem I need to solve is to write code that will only allow for unique values to be added to the tree. For this problem, we are given a mostly complete function, and we just have to add in code that stops it from adding in a value that is already in the tree. The 2nd problem we need to solve is to completely implement code that will check for if the tree contains a value. As this is a custom built binary search tree, they give us a hint that we will need to use recursion to properly solve the problem. The 3rd problem I need to solve involves writing a function to traverse the tree backwards in such a way that it will allow them to be printed to the screen. The 4th problem involves writing code to tell the height of the tree. The 5th problem involves writing code to create a tree from an unsorted list. 
</p>
<p>
    For problem 1, I just had to figure out what the provided code was doing and then add in 2 lines of code that checked if the data being processed was the same as the data in the node and then exit the function. The rest was handled by the existing code.
</p>
<h1>
    Day 262
</h1>
<h3>
    Friday, 9 June, 2023
</h3>
<p>
    Today, I solved the second of my Binary Search Tree problems. The problem I solved today, was to figure out how to write a function to let the program find if a given value was in the tree. We were previously given code that let us add to an item to the tree. They gave us two hints to solve this problem, the first was that we would need to use recursion, and then that we should look at the provided code for the first problem. After pondering on the code from the first problem, I realized that the same process for determining where to put a value in the binary search tree would also let us find a given value. And with just a few modifications, I was able to get a working solution put together. The only problem I ran into was forgetting to add a return statement that was needed in this case to get the recursive call to the function properly working. 
</p>
<h1>
    Day 263
</h1>
<h3>
    Saturday, 10 June, 2023
</h3>
<p>
    Today, I solved 2 more of the 5 problems I need to solve on the binary search tree assignment I am working on. I also realized that my count for the number of days spent coding got off a bit and fixed that. The first problem I solved involved writing code to traverse backwards through the tree. They gave you the hint to look at the traverse forward method they had already written, and that you would need to use the yield keyword to get it done. As I looked at the traverse forward method, I noticed how the first line in the loop seemed to go to the left node, the second just seemed to return the data, and the last went to the right node. So, I decided to simply switch the first and last line and modify which function they were recursively calling. To my complete shock, it worked perfectly. I had no idea of why it worked, or what it was doing, so I used my friendly AI search engine and got a thorough understanding of the solution I stumbled across. From there, I built a function to get the height of the binary search tree. My initial attempts epically failed, and I realized that the reason boiled down to the idea that I did not know enough about how Python handled the custom built binary search tree we were building. So, after I did a bit of study, as in a few hours worth, I got a wonderfully simplified solution to problem built that used built in Python functionality to use recursion to count the number of nodes on the left and the right, and then simply returned the largest of the two values that were created for the left and right branches. 
</p>
<h3>
    Sunday, 11 June, 2023
</h3>
<p>
    Scheduled day off of coding
</p>
<h1>
    Day 264
</h1>
<h3>
    Monday, 12 June, 2023
</h3>
<p>
    Today, was spent trying to analyze the requirements for the last problem of my binary search tree as well as start the planning for how I will solve the problem. 
</p>
<h1>
    Day 265
</h1>
<h3>
    Tuesday, 13 June, 2023
</h3>
<p>
    Got a working solution to problem 5 written. Tomorrow, I will finish my notes and make a post about everything. 
</p>
<h1>
    Day 266
</h1>
<h3>
    Wednesday, 14 June, 2023
</h3>
<p>
    Today, I finally finished solving problem 5 for my Binary search tree program. The challenge was to write code to help the program be fed a single list, find the middle of the list and add that to the binary search tree data structure we finished building with the other 4 challenges, sort through the first and second halves of the list without splitting the list, and sequentially add the middle of each sub list into the tree in the proper order. 
</p>
<p>
    To solve this, I had to learn about how Python handles recursive function calls. More specifically, I had to learn that when you have two recursive calls to a function within a function, Python is smart enough to know how to keep track of everything. In the end, I first built a check to stop the program if it either gets fed an empty list or reaches the end of both sub lists. From there, it will grab the middle of the sorted list, which for a binary search tree is the best way to add numbers, and then will use recursion along with a reference to both first and last that is used to create to sub lists which together ends up adding the first half of the list then the second half of the list creating a balanced binary search tree regardless of the size of the list that is fed into the function. However, given the exclusive use of recursion to solve the problem, if the list fed into the function was of large enough size, it could cause Python to complain about too many calls to the function, which based on my tests, will likely have a stopping point that will vary from computer to computer. 
</p>
<h1>
    Day 267
</h1>
<h3>
    Thursday, 15 June, 2023
</h3>
<p>
    Today, I started working on my final project. I will be writing a tutorial to teach someone else what I have learned in my data structures class this semester. For my tutorial I have to cover 3 topics. The first I need to choose between either teaching about the stack or the queue. The second I need to teach about either a set or a linked list. And the last I need to teach about trees. There are also four other topics we learned about in the class that are not included in the final project, maps, recursion, dynamic arrays, and big-O notation. As I am planning on starting a coding blog, I will likely select all of them, but for the purposes of my final, I will be building a tutorial on stacks, sets, and trees. From there, if I have more time before I turn it in, then I will build more tutorials. 
</p>
<p>
    Thanks to a new friend on Twitter, I learned about Flutter and from my own research the flet plugin for Python. And as I am planning on getting into mobile development, I will be learning my first framework so I can use the experience in Python and then build mobile apps. I already know what my first mobile app will be. It will be a text based choose your own adventure game. I already have the basis of the story, and want to see where it will go. I started it as part of a Python class I took last year. 
</p>
<h1>
    Day 268
</h1>
<h3>
    Friday, 16 June, 2023
</h3>
<p>
    Today, I started working on the outline for my final project. 
</p>
<h1>
    Day 269
</h1>
<h3>
    Saturday, 17 June, 2023
</h3>
<p>
    For my final project, the assignment is to write a tutorial for some of the different things we have learned in the class. The moment I found out about that, I was excited because I want to start a blog and the idea of teaching people about programming, and to me, my final sounds like a perfect way to get that started. For the purposes of the actual final, we only have to teach about 3 of the 9 things we learned about in the class, and have 5 things to choose from. As I am planning on starting a blog, I see no reason to ignore any of the 9 topics and am just planning on doing a tutorial on all of them. For the purposes of my class, I am going to prepare to just do the three I need to do to earn the grade, but if I have enough time, I am going to try to get all 9 tutorials written and turned in. At a bare minimum, I will finish all 9 of them over the summer before I start my last semester of school and finally get my degree. Today, in the process of outlining two of the topics I need to write on, I realized I had built a structure for my blog posts that I could also use for most any programming topic. However, as I contemplated turning it in, I decided to dig deeper into the outline and spend a bit more time preparing before I turn anything in, which leads perfectly into the theme of my blog, digging deeper. If there is one defining attribute about me that could lead to a great blog, it would be the desire to dig deeper and learn more. So, that will be the theme for my blog, it will be a place where I dig deeper into a topic and share my thoughts on it in hopes of helping someone else out in some small way. 
</p>
<h3>
    Saturday, 17 June, 2023
</h3>
<p>
    Scheduled day off Coding
</p>
<h1>
    Day 270
</h1>
<h3>
    Monday, 19 June, 2023
</h3>
<p>
    Today, I studied a bit more into stacks in preparation for my final project. 
</p>
<h1>
    Day 271
</h1>
<h3>
    Tuesday, 20 June, 2023
</h3>
<p>
    Maybe I am going a bit overboard but I found today that the lesson material was not enough for what I would want in teaching about the topics for my final project so I started going online to find more info.
</p>
<h1>
    Day 272
</h1>
<h3>
    Wednesday, 21 June, 2023
</h3>
<p>
    Today, I continued my preparation for my final project and realized what my problem is. I know I want to turn this into a blog, but I am not sure how I want that blog to look or feel. So a lot of my day was about trying to figure that out. 
</p>
<h1>
    Day 273
</h1>
<h3>
    Thursday, 22 June, 2023
</h3>
<p>
    Today I spent more time pondering on my final project. It is slowly moving along, but it is still moving. 
</p>
<h1>
    Day 274
</h1>
<h3>
    Friday, 23 June, 2023
</h3>
<p>
    I finished the outline for the stacks lesson I will be teaching as part of my final. Now, I have a minimum of 2 more outlines to write and I move onto writing the first draft. 
</p>
<h1>
    Day 275
</h1>
<h3>
    Saturday, 24 June, 2023
</h3>
<p>
    It took most of the day, but I finished the outline for my final project. I only have the required parts outlined, but I did plan for more details than is required by the project in each of the three data structures I am going to write about.
</p>