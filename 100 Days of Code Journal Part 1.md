<h1>
    Day 100
</h1>
<h3>
    Friday, 2 December, 2022
</h3>
<p>
    Today, I got set up to work on my <a href="https://byui-cse.github.io/cse121b-course/week05/ponder_prove-wwb.html">05 Prove assignment</a>. I also did a bit of coding on it. Tomorrow I will be spending a few hours trying to get it completed and picking out a project to work on next week. For this project, I am pulling info via json file from a website and reformatting it for display on a different web page. Right now, I have some of the data displayed. I still need to display more data and make sure everything is formatted correctly. 
</p>
<h1>
    Day 101
</h1>
<h3>
    Saturday, 3 December, 2022
</h3>
<p>
    It took a lot of work but I finally got my 05 Prove assignment completed. Running out of time, will have to put more in here later. I spent from about 8 am this morning until just after 6 pm working on my lesson 5 prove assignment. I built a web page that pulled data from a website on temples and pulled data from the json file, placed it into an array, and iterated through the array to place the data in custom created html elements. In the process, I combined different pieces of data about each temple and put it into a combined html article element, then added the ability to sort the different temple articles in either ascending or descending order. The biggest problem I had was in trying to figure out how to clear the data previously generated on the page to allow for it to be sorted another way.
</p>
<h3>
    Sunday, 4 December, 2022
</h3>
<p>
    Scheduled day off of coding
</p>
<h1>
    Day 102
</h1>
<h3>
    Monday, 5 December, 2022
</h3>
<p>
    I studied all of the prepare content for this lesson and started on the first ponder activity for the week. I refactored some food to make it work more efficiently and to actually follow the dry principle. 
</p>
<h1>
    Day 103
</h1>
<h3>
    Tuesday, 6 December, 2022
</h3>
<p>
    Today, I refactored a little more code. I used the JavaScript Map function and pulled data from an array in a more reusable manner than the original code did. I also decided that instead of starting new rounds every time I get to 100, I am just going to keep on counting days. So, instead of being on day 3 of my second round, I am on day 103, because I am not going to stop until either I get a job, or I graduate, whichever comes last. 
</p>
<h1>
    Day 104
</h1>
<h3>
    Wednesday, 7 December, 2022
</h3>
<p>
    I Finished the last of the ponder activities and started mapping out my final project for my JavaScript Class. What I am planning to do, is to build a web page to display some of my poems. I am not sure if I will be able to get all of them put into the page, because of how many I have written (likely somewhere in excess of 5,000). My plan is to pull a picture of the Mount Timpanogos Temple and put it at the top. From there, I will reference that Deanne and I were married there on 13 October 2012 and will calculate how long we have been married. From there, I will give a few options to display love poems beneath a picture of the Mount Timpanogos Temple. This gets into the parts that I am not sure if I will have time to finish, but even if I cannot finish it during class, I will finish it afterwards, because I know my wife will love this project. Ideally, I want to have an option to display every poem that was written on that day, during a prior year, or just a random poem from that day in a prior year. I kind of want a few more options for filtering but I am not sure what else I would want to do yet. 
</p>
<h1>
    Day 105
</h1>
<h3>
    Thursday, 8 December, 2022
</h3>
<p>
    Today, I planned out and started working on my poems webpage. I got a bit of code written and got the files and folders organized. There will be a few things I will have to figure out, but for the most part, I think I should be able to put everything together. 
</p>
<h1>
    Day 106
</h1>
<h3>
    Friday, 9 December, 2022
</h3>
<p>
    Continued working on my webpage and figured out how I will pull a specific array out of a compound array. The data in question, is pulled from a website and gets converted from a JSON file to a JavaScript array. So, I need to be prepared for the data to change, and possibly come in a different order. After trying a few different ways, I will be building a function to loop through the data and check if the templeName key is Mount Timpanogos Temple, and then assigning all of that data to an array and returning it for use in my page. 
</p>
<h1>
    Day 107
</h1>
<h3>
    Saturday, 10 December, 2022
</h3>
<p>
    So far, I have worked for about 4 hours on what is supposed to be a three hour project, and am not even close to being done. I might have just found a fix for an error, that I will be testing out now. 
</p>
<h3>
    Sunday, 11 December, 2022
</h3>
<p>
    Scheduled Day off of Coding
</p>
<h1>
    Day 108 Reflection
</h1>
<h3>
    Monday, 12 December, 2022
</h3>
<p>
    The biggest factor I have found in trying to find good online sources is to first have a good understanding of what I am trying to do, for without that foundation, I have found that too often you end up getting advice on topics that really do not affect what you are trying to accomplish. From there, I have found that the best sources are those that have complete examples which you can implement and try on your own before trying it inside of your code. Just to hear someone explain the syntax of what should happen is not enough, and just to see someone else point out what was wrong with the code, is not enough either. For the best sources, I want to see examples of how the code should look and work along with an explanation of why. Many, but not all, of the answers on Stackoverflow, have wonderful insights. I typically, find that Stackoverflow, is typically a source to better figure out what I am trying to accomplish. For JavaScript, I have found that a lot of sources are kind of hit or miss. 
</p>
<p>
    https://www.educba.com/ has a lot of underwhelming sources, and a few good ones. 
</p>
<p>
    https://www.w3schools.com/ has a lot of really good examples, but not a lot of great explanations. 
</p>
<p>
    https://developer.mozilla.org/en-US/docs/Web/JavaScript has a lot of great examples and wonderful explanations, but is typically hard to navigate. 
</p>
<p>
    YouTube has a lot of wonderful videos, that both let me see live the explanation and the examples, but also has a lot of people who sound like they know what they are talking about but when you try to follow what they are talking about, you quickly find holes. 
</p>
<p>
    Probably the best overall source is a good old fashioned internet search engine (i.e., Google). 
</p>
<p>
    For my processes, I start with a search engine, and try to find a place to start. Often times Stackoverflow ends up on the top of that list. I look at a few questions and answers there, and use that to refine what I am looking for. Sometimes, I luck out and find a direct answer there. From there, if I am still having problems trying to better define what I am trying to accomplish, then I might turn to YouTube. From there, I go back to the search engine and refine my search. At that point, I typically find an answer via one of other sites mentioned above. I do not limit myself to those sites, the ones I mentioned are simply the ones that come up the most. 
</p>
<p>
    One of the reasons I so highly praise both examples and explanation is that it is really hard to fake both when you do not actually know what you are talking about, especially if you provide the code examples for someone like me to test out and experiment with. 
</p>
<h1>
    Day 109
</h1>
<h3>
    Tuesday, 13 December, 2022
</h3>
<p>
    I spent another 2 hours on my program. I learned how to use the find function in JavaScript. Initially, for a reason I could not figure out, when I tried to use the find function, it was pulling the first item in the array regardless of whether it matched the desired results or not. From there I figured out how to implement the find function using arrow notation inside of the main function I am using to find the URL I am looking for, and that almost let me get what I wanted. 
</p>
<p>
    The initial results did not let me pull the image URL out of the compound list. To fix that, I adjusted the export function to specifically export the image. Tomorrow, I am going to attach the image to an HTML element and display our wedding date and try to calculate our how long we have been married. I doubt I will get much farther than that. I really need to get better at estimating how long a project will take. 
</p>
<h1>
    Day 110
</h1>
<h3>
    Wednesday, 14 December, 2022
</h3>
<p>
    Today, I just created a video detailing the code I previously wrote. The big take away I have is that I need to get better at estimating how much I will be able to do. I am happy to be done with this semester. It took a lot out of me. 
</p>
<h1>
    Day 111
</h1>
<h3>
    Thursday, 14 December, 2022
</h3>
<p>
    Light coding day. Got picture attached and cleaned up the HTML a bit. 
</p>
<h1>
    Day 112
</h1>
<h3>
    Friday, 15 December, 2022
</h3>
<p>
    Picked up my study of algorithms again, and discovered that at least part of that study will be carried out via pencil and paper, because it will help me to think efficiently. I also touched up my webpage a little, but most of my work today was reading. 
</p>
<h1>
    Day 113
</h1>
<h3>
    Saturday, 16 December, 2022
</h3>
<p>
    Today in my study of algorithms I learned about big O notation. Big O notation is a measure of the number of steps something will take to compute. For example O(n) means that if you have 10,000 items you are calculating, then it will take 10,000 steps to calculate. While O(n*n) means that if you have 10 items then it will take 100 steps to calculate. 
</p>
<h3>
    Sunday, 17 December, 2022
</h3>
<p>
    Scheduled day off of coding. 
</p>
<h1>
    Day 114
</h1>
<h3>
    Monday, 19 December, 2022
</h3>
<p>
    I finally have a company selected that I want to work at! The first company on my list of companies that I want to work for is Salesforce. 
</p>
<p>
    I just learned what the opposite of raising something to the power of another item is, it is a Logarithm. There are quite a few versions of logarithms that can all impact how we view the efficiency of algorithms. The most efficient algorithms have solid time, and take the same number of steps no matter how many items they are calculating. The next best is a logarithmic algorithm. 
</p>
<h1>
    Day 115
</h1>
<h3>
    Tuesday, 20 December, 2022
</h3>
<p>
    A Eulerian Circuit, or a path that goes through a series of nodes ending in the same place it started and only traveling each path once, is only possible if the sum of all the paths is an even number. 
</p>
<p>
    A multi graph or directed graph is one that has arrows that direct the flow of traffic between one node and another. Hyperlinks between webpages are an example of a directed graph in the internet. 
</p>
<p>
    An acyclic graph is a graph that does not have a cycle like an Eulerian Circuit. Directed Acyclic graphs are often called dags. 
</p>
<h1>
    Day 116
</h1>
<h3>
    Wednesday, 21 December, 2022
</h3>
<p>
    A greedy algorithm is one that tries to find the best solution at each stage. I also learned about finding the best path to different nodes. 
</p>
<h1>
    Day 117
</h1>
<h3>
    Thursday, 22 December, 2022
</h3>
<p>
    Today, I started learning about search algorithms. Obviously ordered search is easier and more efficient that unordered search. The most basic search is compared to finding a needle in a haystack, you just go through the items one by one until you find what you are looking for. Regardless of the method you use for selecting items, (top down, bottom up, or randomly) the principle is the same. I also learned about the basic principles in searching unordered lists. The basic steps of linear or sequential search is that you start at the first item in your list, and move one by one through it until you get to the end.
</p>
<ol>
    <li>Go to the head of the list.</li>
    <li>If the item is the one we are looking for, report that it is found and stop.</li>
    <li>Go to the next item on the list.</li>
    <li>If we are at null, report that the search item was not found and stop. Otherwise, return to step 2.</li>
</ol>
<h1>
    Day 118
</h1>
<h3>
    Friday, 23 December, 2022
</h3>
<p>
    The big O notation for an unordered list is O(n), because in a worst case scenario the search will take a number of steps equal to the number of items we are searching within. 
</p>
<h1>
    Day 119
</h1>
<h3>
    Saturday, 24 December, 2022
</h3>
<p>
    I started learning about the Matthew effect on search today, wherein the search algorithm moves items closer to the top after finding them. One of the first things that came to my mind for the advantage of the Matthew effect is the Pareto principle (or the 80/20). As I thought about the idea of reorganizing the items in the list, I quickly realized that the Pareto principle would eventually take effect and greatly speed up search results. 
</p>
<h3>
    Sunday, 25 December, 2022
</h3>
<p>
    Scheduled day off of coding
</p>
<h1>
    Day 120
</h1>
<h3>
    Monday, 26 December, 2022
</h3>
<p>
    The move-to-front algorithm has you move each item to the front of the list after finding it. An alternative to the move-to-front algorithm is the transposition method, which just moves each item one place forward preventing the least frequently searched items from ever ending up at the front of the list. Together both of these are called self-organizing searches. 
</p>
<h1>
    Day 121
</h1>
<h3>
    Tuesday, 27 December, 2022
</h3>
<p>
    Today I learned about the optimal stopping problem. The way to use the optimal stopping point algorithm is to go through the first 37% of candidates rejecting all of them. Note the best among that group and save it as your benchmark, and then continue with the rest of the candidates selecting the first candidate that is better than your benchmark. 
</p>
<h1>
    Day 122
</h1>
<h3>
    Wednesday, 28 December, 2022
</h3>
<p>
    Today, I learned about binary search. It is a simple principle with powerful applications. Assuming the data is sorted, then you can divide the data in half and check to see which half the desired outcome would be in and instantly cut your search results would be in, and then repeat and from there find the data you are looking for with far less effort than you would otherwise. 
</p>
<h1>
    Day 123
</h1>
<h3>
    Thursday, 29 December, 2022
</h3>
<p>
    Today, I started going through the book Problem Solving with Data Structures and Algorithms using Python. I have set a specific goal for this book, as I study it, I am going to carefully implement and test what I am learning, in addition to taking notes as I go. In this case, the book makes it wonderfully easy as it has a summary at the end, a list of key terms, discussion questions (which I plan to write in detail on), and programming exercises (which I plan to complete). And then between the work each chapter gives and the practice I will do as I go, I should get a nice grasp of actually using algorithms in programming. 
</p>
<h1>
    Day 124
</h1>
<h3>
    Friday, 30 December, 2022
</h3>
<p>
    The goal of a computer scientist is to develop an algorithm that a computer can use to repeatedly solve a problem, in other words algorithms are the solutions a programmer is looking for. More fully, computer science is the study of both the solution to problems and the study of problems with no solutions. Or in other words computer science is the study of the existence and non-existence of algorithms. 
</p>
<dl>
    <dt>Procedural Abstraction</dt>
    <dd>The process of using a tool which you do not fully understand what happens behind the scenes. For example, with the sqrt function from the python math module, you may know how to use it, but lack the knowledge of what happens behind the scenes.</dd>
</dl>
<h1>
    Day 125
</h1>
<h3>
    Saturday, 31 December, 2022
</h3>
<p>
    Today, I started my new class, and learned a bit about git and github. I also practiced with git command line interface and in the process, I learned why the command line is so popular among programmers. When everything else falls apart, you can always turn to the command line and figure out what is happening and maybe even fix it. And from there, I realized that with the command line being used to fix so many problems, the idea of using the command line would just become natural.
</p>
<h3>
    Sunday, 1 January, 2023
</h3>
<p>
    Scheduled day off of coding.
</p>
<h1>
    Day 126
</h1>
<h3>
    Monday, 2 January, 2023
</h3>
<p>
    For my study of algorithms, I learned that to truly excel at computer programming I need to learn to think in terms of creating steps to solve a problem and then translate that into a computer program. I did not have a lot of time today to study today, because of my classes starting and my new job, but I plan on continuing my study every day. And more importantly, I am looking for something I can do each day. And while my dedicated study of algorithms did not give me anything to do, when I study for my programming with classes class later on today, it will give me plenty to do and I plan on applying what I am learning in algorithms in the assignment that I am going to be doing tonight. 
</p>
<p>
    Today, I wrote my first two programs in C#. The first simply got the first and last name from the user and then returned it via a format string with their last name first and then their first and last name. The second program, got a percentage (entered as a whole number without a percent symbol) from the user and then returned a grade on that score. 
</p>
<h1>
    Day 127
</h1>
<h3>
    Tuesday, 3 January, 2023
</h3>
<p>
    Today, I learned that data structures and abstract data types are used to manage the complexity of the problem solving process. By abstracting the problem, we are able to remove some of the complexity behind the problem and better focus on the problem itself. It is a way to take the data that you would normally be part of the problem, put it behind a wall to get it out of sight and then focus solely on the problem itself. And while in classroom settings, this process might seem overly cumbersome, when you get to bigger problems that you might find in real life, it is a critical skill to have.
</p>
<p>
    Today, I completed the Learning Activity - C# Prep 3 assignment for my Programming with Classes class, where I wrote a program to generate a random number and have the user provide guesses until they guessed the number. After the user guessed the number, I added the functionality to let the user play again. I also added the functionality to track how many guesses it took the user to guess the number. 
</p>
<h1>
    Day 128
</h1>
<h3>
    Wednesday, 4 January, 2023
</h3>
<p>
    The end goal of computer programming is to create a way for a computer to solve a problem that people have, and free up our personal resources to do things we enjoy more. However, not all problems are equal. Some problems simply do not have solutions that can be turned into a set of rational steps, and other problems are so complex that despite a proper solution existing, the resources required would be so intensive that to even try to design a computer program to solve them would be a waste of time. This is why the study of algorithms is important. An algorithm gives us a way, independent of a computer (which will have varying amount of resources) to evaluate a problem. 
</p>
<p>
    Today, I finished my C# Prep 4 Overview assignment and its two stretch goals. For this assignment, I wrote a program that let the user continuously enter in numbers that get added to a list, until they enter the number 0. The program will then sum all of the numbers, average them out, find the largest number, the smallest positive number, sort the list, and finally display all of that to the user. 
</p>
<h1>
    Day 129
</h1>
<h3>
    Thursday, 5 January, 2023
</h3>
<p>
    Today, I finished the last of my week 2 prove assignment. The code I wrote today, used functions to collect two different types of data from the user, pass that data to another function, and use it in various ways. Tomorrow, I start my first formal lesson on classes. I am looking forward to it.
</p>
<h1>
    Day 130
</h1>
<h3>
    Friday, 6 January, 2023
</h3>
<p>
    Today was a light day of coding. I got sick today, and had to take it easy. I reviewed some of the basics of Python and learned about building classes in C#. 
</p>
<h1>
    Day 131
</h1>
<h3>
    Saturday, 7 January, 2023
</h3>
<p>
    Today, was another light day of coding. I technically put in about 2 hours of work but barely got anything done because my head is foggy from whatever illness I am fighting off. 
</p>
<h3>
    Sunday, 8 January, 2023
</h3>
<p>
    Scheduled day off of coding.
</p>
<h1>
    Day 132
</h1>
<h3>
    Monday, 9 January, 2023
</h3>
<p>
    Today, was another light day of coding. Tomorrow will also be another light day. I am almost better. Today, most of my time off work was spent at a viewing for my wife's aunt. Tomorrow, will either be spent making up for time spent at her funeral, or will be spent coding properly. I will find that out tomorrow. Today, I reviewed a bit of Python and wrote a bit more code on my first class.
</p>
<h1>
    Day 133
</h1>
<h3>
    Tuesday, 10 January, 2023
</h3>
<p>
    Today, I was able to finish my first class. I need to write one more before I will be able to test it, but I have confidence in what I wrote and either way, tomorrow, I will know for sure. 
</p>
<h1>
    Day 134
</h1>
<h3>
    Wednesday, 11 January, 2023
</h3>
<p>
    Today, I finished building and testing my first program using classes. To write the program that acts as a digital resume. One class stores your individual jobs, with member variables that individually store, the company name, job title, start year, and end year. Then a method that is used to display the job to the console. The other class collects each job into a list, stores the person's name, and then uses both its own display methods and the display methods from the other class to display the whole resume to the console. 
</p>
<h1>
    Day 135
</h1>
<h3>
    Thursday, 12 January, 2023
</h3>
<p>
    Today, I started work on my first group project of the semester. The project is a lesson on abstraction. We are first going to map out the requirements of the program, and then create an outline of everything we are going to put into the program. From there, after we have completed that, we will then work individually on writing the program. Right now, I have finished about half of the prep work that is required for the group project. 
</p>
<h1>
    Day 136
</h1>
<h3>
    Friday, 13 January, 2023
</h3>
<p>
    Today, I got a little farther on my outline of my next program. I plan to get the whole program outlined to as fine of detail as I can, before actually starting to write it. I have my first class outlined. As currently planned, I will have my program broken up into 6 separate classes. 
</p>
<h1>
    Day 137
</h1>
<h3>
    Saturday, 14 January, 2023
</h3>
<p>
    Today, I expanded out the number of classes I will be writing and filled in the details for how (at least in part) 5 of those classes will work. I still need to outline the details to at least three more classes, and then (unless I add more classes later) I should be ready to start coding. As I have been taking the time to map out what I am going to be writing, I have found that I have been solving some of the problems I know I would have ran into during the actual coding process. I think I like taking the time to outline a program before writing it. 
</p>